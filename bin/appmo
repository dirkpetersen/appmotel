#!/usr/bin/env bash

# -----------------------------------------------------------------------------
# Script Name: appmo
# Description: CLI tool for managing Appmotel applications
# -----------------------------------------------------------------------------

set -o errexit
set -o nounset
set -o pipefail
IFS=$'\n\t'

# Temp file tracking for cleanup
declare -a TEMP_FILES=()

# -----------------------------------------------------------------------------
# Function: cleanup_temp_files
# Description: Remove all tracked temp files on exit
# -----------------------------------------------------------------------------
cleanup_temp_files() {
  for tmp_file in "${TEMP_FILES[@]:-}"; do
    [[ -n "${tmp_file}" ]] && rm -f "${tmp_file}" 2>/dev/null || true
  done
}
trap cleanup_temp_files EXIT

# -----------------------------------------------------------------------------
# Function: create_temp_file
# Description: Create a temp file and register it for cleanup
# -----------------------------------------------------------------------------
create_temp_file() {
  local prefix="${1:-appmo}"
  local tmp_file
  tmp_file=$(mktemp "/tmp/${prefix}_$$.XXXXXX")
  TEMP_FILES+=("${tmp_file}")
  echo "${tmp_file}"
}

# Constants
readonly APPMOTEL_HOME="/home/appmotel"
readonly APPMOTEL_CONFIG_DIR="${APPMOTEL_HOME}/.config/appmotel"
readonly APPMOTEL_ENV_FILE="${APPMOTEL_CONFIG_DIR}/.env"
readonly APPS_CONFIG_DIR="${APPMOTEL_CONFIG_DIR}"
readonly APPS_DATA_DIR="${APPMOTEL_HOME}/.local/share/appmotel"
readonly TRAEFIK_DYNAMIC_DIR="${APPMOTEL_HOME}/.config/traefik/dynamic"
readonly SYSTEMD_USER_DIR="${APPMOTEL_HOME}/.config/systemd/user"
readonly BACKUPS_DIR="${APPMOTEL_HOME}/.local/share/appmotel-backups"
readonly MIN_PORT=10001
readonly MAX_PORT=59999

# Load appmotel configuration
# Note: Temporarily reset IFS for proper .env parsing, then restore
if [[ -f "${APPMOTEL_ENV_FILE}" ]]; then
  _saved_ifs="${IFS}"
  IFS=$' \t\n'
  # shellcheck source=/dev/null
  source "${APPMOTEL_ENV_FILE}"
  IFS="${_saved_ifs}"
  unset _saved_ifs
fi

# Default resource limits (can be overridden in .env)
readonly DEFAULT_MEMORY_LIMIT="512M"
readonly DEFAULT_CPU_QUOTA="100%"

# Rate limiting defaults
readonly DEFAULT_RATE_LIMIT_AVG=100
readonly DEFAULT_RATE_LIMIT_BURST=50

# Ensure XDG_RUNTIME_DIR is set for systemd --user commands
export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"

# -----------------------------------------------------------------------------
# Function: log_msg
# Description: Prints messages with timestamp
# -----------------------------------------------------------------------------
log_msg() {
  local level="$1"
  local msg="$2"
  printf "[%(%Y-%m-%d %H:%M:%S)T] [%s] %s\n" -1 "${level}" "${msg}" >&2
}

# -----------------------------------------------------------------------------
# Function: die
# Description: Prints error message and exits
# -----------------------------------------------------------------------------
die() {
  log_msg "ERROR" "$1"
  exit 1
}

# -----------------------------------------------------------------------------
# Function: safe_cd
# Description: Change directory with error context
# -----------------------------------------------------------------------------
safe_cd() {
  local target="$1"
  local context="${2:-}"

  if [[ ! -d "${target}" ]]; then
    if [[ -n "${context}" ]]; then
      die "Cannot change to directory '${target}': directory does not exist (${context})"
    else
      die "Cannot change to directory '${target}': directory does not exist"
    fi
  fi

  cd "${target}" || die "Failed to change to directory '${target}'"
}

# -----------------------------------------------------------------------------
# Function: systemctl_stop
# Description: Stop a systemd service, logging warnings on unexpected errors
# -----------------------------------------------------------------------------
systemctl_stop() {
  local service_name="$1"
  local is_user="${2:-true}"  # true for --user services, false for system services

  local output
  local exit_code

  if [[ "${is_user}" == "true" ]]; then
    output=$(systemctl --user stop "${service_name}" 2>&1) && exit_code=0 || exit_code=$?
  else
    output=$(sudo /bin/systemctl stop "${service_name}" 2>&1) && exit_code=0 || exit_code=$?
  fi

  # Exit code 5 means service not loaded (already stopped/doesn't exist) - this is OK
  if [[ ${exit_code} -ne 0 ]] && [[ ${exit_code} -ne 5 ]]; then
    log_msg "WARN" "Failed to stop ${service_name} (exit ${exit_code}): ${output}"
  fi

  return 0  # Always return success - stop failures shouldn't halt operations
}

# -----------------------------------------------------------------------------
# Function: git_with_timeout
# Description: Run git commands with a timeout to prevent hanging
# -----------------------------------------------------------------------------
git_with_timeout() {
  local timeout_secs="${GIT_TIMEOUT:-120}"  # Default 2 minutes
  timeout "${timeout_secs}" git "$@"
}

# -----------------------------------------------------------------------------
# Function: check_disk_space
# Description: Check if sufficient disk space is available
# Arguments: path, required_mb
# -----------------------------------------------------------------------------
check_disk_space() {
  local path="$1"
  local required_mb="${2:-100}"  # Default 100MB minimum

  # Get available space in MB
  local available_mb
  available_mb=$(df -m "${path}" 2>/dev/null | awk 'NR==2 {print $4}')

  if [[ -z "${available_mb}" ]]; then
    log_msg "WARN" "Could not check disk space for ${path}"
    return 0  # Continue anyway
  fi

  if [[ ${available_mb} -lt ${required_mb} ]]; then
    die "Insufficient disk space: ${available_mb}MB available, ${required_mb}MB required at ${path}"
  fi

  return 0
}

# -----------------------------------------------------------------------------
# Function: safe_rm_rf
# Description: Safely remove a directory with validation checks
# Prevents accidental deletion of critical directories
# -----------------------------------------------------------------------------
safe_rm_rf() {
  local target="$1"
  local context="${2:-unknown operation}"

  # Validate target is not empty
  if [[ -z "${target}" ]]; then
    die "safe_rm_rf: empty path provided during ${context}"
  fi

  # Resolve to absolute path
  local abs_target
  abs_target=$(realpath -m "${target}" 2>/dev/null || echo "${target}")

  # Validate path is within allowed directories
  local allowed_prefixes=(
    "${APPS_DATA_DIR}"
    "${APPS_CONFIG_DIR}"
    "${BACKUPS_DIR}"
    "${SYSTEMD_USER_DIR}"
    "${TRAEFIK_DYNAMIC_DIR}"
  )

  local path_allowed=false
  for prefix in "${allowed_prefixes[@]}"; do
    if [[ "${abs_target}" == "${prefix}"/* ]]; then
      path_allowed=true
      break
    fi
  done

  if [[ "${path_allowed}" != "true" ]]; then
    die "safe_rm_rf: refusing to remove '${abs_target}' - not in allowed directories (${context})"
  fi

  # Additional safety: prevent removal of root-level appmotel directories
  if [[ "${abs_target}" == "${APPS_DATA_DIR}" ]] || \
     [[ "${abs_target}" == "${APPS_CONFIG_DIR}" ]] || \
     [[ "${abs_target}" == "${BACKUPS_DIR}" ]] || \
     [[ "${abs_target}" == "${APPMOTEL_HOME}" ]] || \
     [[ "${abs_target}" == "/" ]]; then
    die "safe_rm_rf: refusing to remove critical directory '${abs_target}' (${context})"
  fi

  # Path is valid, proceed with removal
  rm -rf "${target}"
}

# -----------------------------------------------------------------------------
# Function: safe_source_env
# Description: Safely source an .env file, only allowing KEY=VALUE lines
# Rejects lines with command substitution, semicolons, or other dangerous chars
# -----------------------------------------------------------------------------
safe_source_env() {
  local env_file="$1"
  local strict="${2:-false}"  # If true, fail on invalid lines

  if [[ ! -f "${env_file}" ]]; then
    return 1
  fi

  local line_num=0
  local saved_ifs="${IFS}"
  IFS=$' \t\n'

  while IFS= read -r line || [[ -n "${line}" ]]; do
    line_num=$((line_num + 1))

    # Skip empty lines and comments
    [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue

    # Strip leading/trailing whitespace
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"

    # Validate: must be KEY=VALUE format
    # KEY: alphanumeric and underscore only, must start with letter or underscore
    # VALUE: can be quoted or unquoted, no command substitution or dangerous chars
    if [[ "${line}" =~ ^[a-zA-Z_][a-zA-Z0-9_]*= ]]; then
      local key="${line%%=*}"
      local value="${line#*=}"

      # Check for dangerous patterns in value
      # Reject: $(...), `...`, ;, &&, ||, |, >, <, \n in value
      if [[ "${value}" =~ \$\( ]] || \
         [[ "${value}" =~ \` ]] || \
         [[ "${value}" =~ \; ]] || \
         [[ "${value}" =~ \&\& ]] || \
         [[ "${value}" =~ \|\| ]] || \
         [[ "${value}" =~ \| ]] && [[ ! "${value}" =~ ^[\"\'][^\"\']*[\"\']$ ]]; then
        if [[ "${strict}" == "true" ]]; then
          IFS="${saved_ifs}"
          die "Invalid .env file '${env_file}': dangerous pattern at line ${line_num}"
        fi
        log_msg "WARN" "Skipping suspicious line ${line_num} in ${env_file}"
        continue
      fi

      # Remove surrounding quotes if present
      if [[ "${value}" =~ ^\"(.*)\"$ ]] || [[ "${value}" =~ ^\'(.*)\'$ ]]; then
        value="${BASH_REMATCH[1]}"
      fi

      # Export the variable
      export "${key}=${value}"
    else
      if [[ "${strict}" == "true" ]]; then
        IFS="${saved_ifs}"
        die "Invalid .env file '${env_file}': malformed line ${line_num}"
      fi
      log_msg "WARN" "Skipping invalid line ${line_num} in ${env_file}"
    fi
  done < "${env_file}"

  IFS="${saved_ifs}"
}

# -----------------------------------------------------------------------------
# Function: safe_source_metadata
# Description: Safely source a metadata.conf file with strict validation
# Only allows specific known keys used by appmotel
# -----------------------------------------------------------------------------
safe_source_metadata() {
  local metadata_file="$1"

  if [[ ! -f "${metadata_file}" ]]; then
    return 1
  fi

  # Known valid metadata keys
  local -a valid_keys=("APP_NAME" "GITHUB_URL" "BRANCH" "PORT" "LAST_DEPLOYMENT" "SERVICES" "SUBDIR")

  local line_num=0
  while IFS= read -r line || [[ -n "${line}" ]]; do
    line_num=$((line_num + 1))

    # Skip empty lines and comments
    [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue

    # Strip whitespace
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"

    if [[ "${line}" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      # Only allow known keys
      local key_valid=false
      for valid_key in "${valid_keys[@]}"; do
        if [[ "${key}" == "${valid_key}" ]]; then
          key_valid=true
          break
        fi
      done

      if [[ "${key_valid}" != "true" ]]; then
        die "Invalid metadata file '${metadata_file}': unknown key '${key}' at line ${line_num}"
      fi

      # Check for dangerous patterns
      if [[ "${value}" =~ \$\( ]] || [[ "${value}" =~ \` ]] || [[ "${value}" =~ \; ]]; then
        die "Invalid metadata file '${metadata_file}': dangerous pattern at line ${line_num}"
      fi

      # Remove surrounding quotes
      if [[ "${value}" =~ ^\"(.*)\"$ ]] || [[ "${value}" =~ ^\'(.*)\'$ ]]; then
        value="${BASH_REMATCH[1]}"
      fi

      # Set variable in current scope
      declare -g "${key}=${value}"
    else
      die "Invalid metadata file '${metadata_file}': malformed line ${line_num}"
    fi
  done < "${metadata_file}"
}

# -----------------------------------------------------------------------------
# Function: format_timestamp
# Description: Converts UTC timestamp to configured timezone for display
# Input: UTC timestamp in ISO 8601 format (e.g., 2025-12-17T19:58:08Z)
# Output: Human-readable timestamp in configured timezone
# -----------------------------------------------------------------------------
format_timestamp() {
  local utc_timestamp="$1"
  local tz="${TZ:-UTC}"

  if [[ -z "${utc_timestamp}" ]]; then
    echo "N/A"
    return
  fi

  # Use date command with TZ environment variable to convert
  # GNU date can parse ISO 8601 format directly
  local formatted
  if formatted=$(TZ="${tz}" date -d "${utc_timestamp}" "+%Y-%m-%d %H:%M:%S %Z" 2>/dev/null); then
    echo "${formatted}"
  else
    # Fallback: return original timestamp if conversion fails
    echo "${utc_timestamp}"
  fi
}

# -----------------------------------------------------------------------------
# Function: usage
# Description: Prints usage information
# -----------------------------------------------------------------------------
usage() {
  cat <<EOF
Usage: appmo <command> [arguments]

Commands:
  add <app-name> <url|user/repo> [branch]  Add and deploy a new app (default: main)
  remove <app-name>                      Remove an app (alias: rm)
  list                                   List all configured apps (alias: ls)
  status [app-name]                      Show app status
  start <app-name>                       Start an app
  stop <app-name>                        Stop an app
  restart <app-name>                     Restart an app
  update <app-name>                      Manually update an app
  check [app-name]                       Check for available updates (no deploy)
  autopull                               Check all apps for updates and deploy
  logs <app-name> [lines]                View app logs
  env <app-name>                         Edit app's .env file in default editor
  exec <app-name> <command>              Run command in app's environment
  backup <app-name>                      Create a backup of an app
  restore <app-name> [backup-id]         Restore an app from backup
  backups <app-name>                     List available backups for an app

URL Formats:
  user/repo                              Short form (expands to GitHub)
  https://github.com/user/repo           Standard GitHub URL
  https://github.com/user/repo/tree/branch/path/to/folder
                                         Deploy from a subfolder

Examples:
  appmo add myapp https://github.com/user/repo main
  appmo add myapp https://github.com/user/repo/tree/main/apps/myapp
  appmo status myapp
  appmo autopull
  appmo logs myapp 50
  appmo env myapp
  appmo backup myapp
  appmo restore myapp 2024-01-15-120000
EOF
  exit 0
}

# -----------------------------------------------------------------------------
# Function: validate_app_name
# Description: Validates app name format
# -----------------------------------------------------------------------------
validate_app_name() {
  local app_name="$1"

  if [[ -z "${app_name}" ]]; then
    die "App name cannot be empty"
  fi

  if [[ "${app_name}" =~ [[:space:]] ]]; then
    die "App name cannot contain spaces"
  fi

  if [[ ! "${app_name}" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$ ]]; then
    die "App name must be a valid DNS subdomain label (lowercase alphanumeric and hyphens only)"
  fi
}

# -----------------------------------------------------------------------------
# Function: validate_github_url
# Description: Validates GitHub URL format
# -----------------------------------------------------------------------------
validate_github_url() {
  local url="$1"

  if [[ -z "${url}" ]]; then
    die "GitHub URL cannot be empty"
  fi

  # Check for path traversal attempts
  if [[ "${url}" =~ \.\. ]]; then
    die "Invalid GitHub URL: path traversal not allowed"
  fi

  # Accept full URLs or user/repo shorthand
  if [[ "${url}" =~ ^https?:// ]] || [[ "${url}" =~ ^git@ ]]; then
    # Full URL - basic validation
    if [[ ! "${url}" =~ ^(https?://|git@)[a-zA-Z0-9._-]+[:/][a-zA-Z0-9._/-]+$ ]]; then
      die "Invalid GitHub URL format: ${url}"
    fi
  elif [[ "${url}" =~ ^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$ ]]; then
    # user/repo shorthand - this is valid
    :
  else
    die "Invalid GitHub URL format. Use https://github.com/user/repo or user/repo"
  fi
}

# -----------------------------------------------------------------------------
# Function: parse_github_url
# Description: Parses GitHub URL to extract repo URL, branch, and subfolder
# Input:  https://github.com/user/repo/tree/branch/path/to/folder
# Output: Sets global variables: PARSED_REPO_URL, PARSED_BRANCH, PARSED_SUBDIR
# -----------------------------------------------------------------------------
parse_github_url() {
  local url="$1"

  # Reset output variables
  PARSED_REPO_URL=""
  PARSED_BRANCH=""
  PARSED_SUBDIR=""

  # Check if URL contains /tree/ pattern (GitHub subfolder URL)
  if [[ "${url}" =~ ^(https://github\.com/[^/]+/[^/]+)/tree/([^/]+)/(.+)$ ]]; then
    # Full URL with subfolder: https://github.com/user/repo/tree/branch/path/to/folder
    PARSED_REPO_URL="${BASH_REMATCH[1]}"
    PARSED_BRANCH="${BASH_REMATCH[2]}"
    PARSED_SUBDIR="${BASH_REMATCH[3]}"
    # Remove trailing slash if present
    PARSED_SUBDIR="${PARSED_SUBDIR%/}"
  elif [[ "${url}" =~ ^(https://github\.com/[^/]+/[^/]+)/tree/([^/]+)/?$ ]]; then
    # URL with branch but no subfolder: https://github.com/user/repo/tree/branch
    PARSED_REPO_URL="${BASH_REMATCH[1]}"
    PARSED_BRANCH="${BASH_REMATCH[2]}"
  elif [[ "${url}" =~ ^(https://github\.com/[^/]+/[^/]+)/?$ ]]; then
    # Standard URL: https://github.com/user/repo
    PARSED_REPO_URL="${BASH_REMATCH[1]}"
  elif [[ "${url}" =~ ^(git@github\.com:[^/]+/[^/]+)(\.git)?$ ]]; then
    # SSH URL: git@github.com:user/repo.git
    PARSED_REPO_URL="${BASH_REMATCH[1]}"
  elif [[ "${url}" =~ ^([a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+)$ ]]; then
    # Shorthand: user/repo
    PARSED_REPO_URL="https://github.com/${BASH_REMATCH[1]}"
  else
    # Unrecognized format - let validate_github_url handle it
    PARSED_REPO_URL="${url}"
  fi
}

# -----------------------------------------------------------------------------
# Function: find_env_template_up
# Description: Search for .env template files starting from a directory and going up
# Arguments: start_dir, stop_dir (don't search above this)
# Returns: Path to found template or empty string
# -----------------------------------------------------------------------------
find_env_template_up() {
  local start_dir="$1"
  local stop_dir="$2"

  local current_dir="${start_dir}"
  local templates=(".env.default" "env.default" ".env.example" "env.example" ".env.local" ".env")

  while [[ "${current_dir}" == "${stop_dir}"* ]]; do
    for tmpl in "${templates[@]}"; do
      if [[ -f "${current_dir}/${tmpl}" ]]; then
        echo "${current_dir}/${tmpl}"
        return 0
      fi
    done

    # Move up one directory
    local parent_dir
    parent_dir=$(dirname "${current_dir}")

    # Stop if we've reached the stop_dir or can't go higher
    if [[ "${parent_dir}" == "${current_dir}" ]] || [[ "${current_dir}" == "${stop_dir}" ]]; then
      break
    fi

    current_dir="${parent_dir}"
  done

  return 1
}

# -----------------------------------------------------------------------------
# Function: find_file_up
# Description: Search for a file starting from a directory and going up
# Arguments: filename, start_dir, stop_dir (don't search above this)
# Returns: Path to found file or empty string
# -----------------------------------------------------------------------------
find_file_up() {
  local filename="$1"
  local start_dir="$2"
  local stop_dir="$3"

  local current_dir="${start_dir}"

  while [[ "${current_dir}" == "${stop_dir}"* ]]; do
    if [[ -f "${current_dir}/${filename}" ]]; then
      echo "${current_dir}"
      return 0
    fi

    # Move up one directory
    local parent_dir
    parent_dir=$(dirname "${current_dir}")

    # Stop if we've reached the stop_dir or can't go higher
    if [[ "${parent_dir}" == "${current_dir}" ]] || [[ "${current_dir}" == "${stop_dir}" ]]; then
      break
    fi

    current_dir="${parent_dir}"
  done

  return 1
}

# -----------------------------------------------------------------------------
# Function: validate_branch_name
# Description: Validates git branch name
# -----------------------------------------------------------------------------
validate_branch_name() {
  local branch="$1"

  if [[ -z "${branch}" ]]; then
    die "Branch name cannot be empty"
  fi

  # Check for path traversal and dangerous characters
  if [[ "${branch}" =~ \.\. ]] || \
     [[ "${branch}" =~ [[:space:]] ]] || \
     [[ "${branch}" =~ [\;\|\&\$\`] ]]; then
    die "Invalid branch name: contains dangerous characters"
  fi

  # Git branch names have specific rules
  # https://git-scm.com/docs/git-check-ref-format
  if [[ ! "${branch}" =~ ^[a-zA-Z0-9_./-]+$ ]]; then
    die "Invalid branch name: must contain only alphanumeric, dot, underscore, hyphen, or slash"
  fi

  # Cannot start or end with slash or dot
  if [[ "${branch}" =~ ^[./] ]] || [[ "${branch}" =~ [./]$ ]]; then
    die "Invalid branch name: cannot start or end with slash or dot"
  fi
}

# -----------------------------------------------------------------------------
# Function: app_exists
# Description: Checks if an app exists (must have metadata.conf to be considered deployed)
# Note: A directory with only .env.backup from a removed app doesn't count
# -----------------------------------------------------------------------------
app_exists() {
  local app_name="$1"
  [[ -f "${APPS_CONFIG_DIR}/${app_name}/metadata.conf" ]]
}

# -----------------------------------------------------------------------------
# Function: require_app_exists
# Description: Ensures app exists or exits
# -----------------------------------------------------------------------------
require_app_exists() {
  local app_name="$1"
  if ! app_exists "${app_name}"; then
    die "App '${app_name}' does not exist"
  fi
}

# -----------------------------------------------------------------------------
# Function: create_backup
# Description: Creates a backup of an app's data and config
# -----------------------------------------------------------------------------
create_backup() {
  local app_name="$1"
  local backup_id
  backup_id=$(date +%Y-%m-%d-%H%M%S)
  local backup_dir="${BACKUPS_DIR}/${app_name}/${backup_id}"
  local backup_warnings=false

  # Check disk space before creating backup (require at least 200MB)
  check_disk_space "${BACKUPS_DIR}" 200

  mkdir -p "${backup_dir}"

  # Backup config
  if [[ -d "${APPS_CONFIG_DIR}/${app_name}" ]]; then
    if ! cp -r "${APPS_CONFIG_DIR}/${app_name}" "${backup_dir}/config"; then
      log_msg "WARN" "Failed to backup config directory"
      backup_warnings=true
    fi
  fi

  # Backup repo (excluding .venv and node_modules to save space)
  if [[ -d "${APPS_DATA_DIR}/${app_name}/repo" ]]; then
    if ! tar --exclude='.venv' --exclude='node_modules' --exclude='.git' \
        -czf "${backup_dir}/repo.tar.gz" \
        -C "${APPS_DATA_DIR}/${app_name}" repo 2>/dev/null; then
      log_msg "WARN" "Failed to backup repo (tar failed - disk full?)"
      backup_warnings=true
    fi
  fi

  # Backup all systemd service files for this app (including multi-component)
  for service_file in "${SYSTEMD_USER_DIR}"/appmotel-${app_name}*.service; do
    if [[ -f "${service_file}" ]]; then
      if ! cp "${service_file}" "${backup_dir}/"; then
        log_msg "WARN" "Failed to backup service file: $(basename "${service_file}")"
        backup_warnings=true
      fi
    fi
  done

  # Backup Traefik config
  if [[ -f "${TRAEFIK_DYNAMIC_DIR}/${app_name}.yaml" ]]; then
    if ! cp "${TRAEFIK_DYNAMIC_DIR}/${app_name}.yaml" "${backup_dir}/"; then
      log_msg "WARN" "Failed to backup Traefik config"
      backup_warnings=true
    fi
  fi

  echo "${backup_id}"
  if [[ "${backup_warnings}" == "true" ]]; then
    log_msg "WARN" "Backup created with warnings: ${backup_id}"
  else
    log_msg "INFO" "Backup created: ${backup_id}"
  fi
}

# -----------------------------------------------------------------------------
# Function: restore_backup
# Description: Restores an app from a backup
# Returns: 0 on success, 1 on failure
# -----------------------------------------------------------------------------
restore_backup() {
  local app_name="$1"
  local backup_id="$2"
  local backup_dir="${BACKUPS_DIR}/${app_name}/${backup_id}"
  local restore_failed=false

  if [[ ! -d "${backup_dir}" ]]; then
    log_msg "ERROR" "Backup '${backup_id}' not found for app '${app_name}'"
    return 1
  fi

  log_msg "INFO" "Restoring from backup: ${backup_id}"

  # Stop all services if running
  local -a services
  if get_all_services "${app_name}" services 2>/dev/null; then
    for service in "${services[@]}"; do
      local service_name
      if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
        service_name="appmotel-${app_name}"
      else
        service_name="appmotel-${app_name}-${service}"
      fi
      systemctl_stop "${service_name}"
    done
  else
    systemctl_stop "appmotel-${app_name}"
  fi

  # Restore config
  if [[ -d "${backup_dir}/config" ]]; then
    safe_rm_rf "${APPS_CONFIG_DIR}/${app_name}" "restore_backup config"
    if ! cp -r "${backup_dir}/config" "${APPS_CONFIG_DIR}/${app_name}"; then
      log_msg "ERROR" "Failed to restore config directory"
      restore_failed=true
    fi
  fi

  # Restore repo
  if [[ -f "${backup_dir}/repo.tar.gz" ]]; then
    safe_rm_rf "${APPS_DATA_DIR}/${app_name}/repo" "restore_backup repo"
    mkdir -p "${APPS_DATA_DIR}/${app_name}"
    if ! tar -xzf "${backup_dir}/repo.tar.gz" -C "${APPS_DATA_DIR}/${app_name}"; then
      log_msg "ERROR" "Failed to restore repo from backup archive"
      restore_failed=true
    fi
  fi

  # Restore systemd service(s)
  for service_file in "${backup_dir}"/appmotel-${app_name}*.service; do
    if [[ -f "${service_file}" ]]; then
      if ! cp "${service_file}" "${SYSTEMD_USER_DIR}/"; then
        log_msg "ERROR" "Failed to restore systemd service: $(basename "${service_file}")"
        restore_failed=true
      fi
    fi
  done
  systemctl --user daemon-reload

  # Restore Traefik config
  if [[ -f "${backup_dir}/${app_name}.yaml" ]]; then
    if ! cp "${backup_dir}/${app_name}.yaml" "${TRAEFIK_DYNAMIC_DIR}/"; then
      log_msg "ERROR" "Failed to restore Traefik config"
      restore_failed=true
    fi
  fi

  # Only reinstall dependencies if repo restore succeeded
  if [[ "${restore_failed}" == "false" ]]; then
    local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"
    if [[ -f "${repo_dir}/go.mod" ]]; then
      if ! setup_go_env "${repo_dir}"; then
        log_msg "ERROR" "Failed to reinstall Go dependencies"
        restore_failed=true
      fi
    elif [[ -f "${repo_dir}/requirements.txt" ]] || [[ -f "${repo_dir}/pyproject.toml" ]]; then
      if ! setup_python_env "${repo_dir}"; then
        log_msg "ERROR" "Failed to reinstall Python dependencies"
        restore_failed=true
      fi
    elif [[ -f "${repo_dir}/package.json" ]]; then
      if ! setup_nodejs_env "${repo_dir}"; then
        log_msg "ERROR" "Failed to reinstall Node.js dependencies"
        restore_failed=true
      fi
    fi
  fi

  # Start service(s)
  if [[ "${restore_failed}" == "false" ]]; then
    if get_all_services "${app_name}" services 2>/dev/null; then
      for service in "${services[@]}"; do
        local service_name
        if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
          service_name="appmotel-${app_name}"
        else
          service_name="appmotel-${app_name}-${service}"
        fi
        if ! systemctl --user start "${service_name}"; then
          log_msg "ERROR" "Failed to start service: ${service_name}"
          restore_failed=true
        fi
      done
    else
      if ! systemctl --user start "appmotel-${app_name}"; then
        log_msg "ERROR" "Failed to start service: appmotel-${app_name}"
        restore_failed=true
      fi
    fi
  fi

  if [[ "${restore_failed}" == "true" ]]; then
    log_msg "ERROR" "Restore completed with errors - app may be in inconsistent state"
    return 1
  fi

  log_msg "INFO" "Restore completed successfully"
  return 0
}

# -----------------------------------------------------------------------------
# Function: list_backups
# Description: Lists available backups for an app
# -----------------------------------------------------------------------------
list_backups() {
  local app_name="$1"
  local backup_base="${BACKUPS_DIR}/${app_name}"

  if [[ ! -d "${backup_base}" ]]; then
    log_msg "INFO" "No backups found for app '${app_name}'"
    return
  fi

  printf "%-25s %s\n" "BACKUP ID" "SIZE"
  printf "%-25s %s\n" "---------" "----"

  for backup_dir in "${backup_base}"/*; do
    if [[ -d "${backup_dir}" ]]; then
      local backup_id
      backup_id=$(basename "${backup_dir}")
      local size
      size=$(du -sh "${backup_dir}" 2>/dev/null | cut -f1)
      printf "%-25s %s\n" "${backup_id}" "${size}"
    fi
  done
}

# -----------------------------------------------------------------------------
# Function: parse_env_file
# Description: Parses .env file handling quotes and special characters
# Returns: Variable assignments that can be evaluated
# -----------------------------------------------------------------------------
parse_env_file() {
  local env_file="$1"

  if [[ ! -f "${env_file}" ]]; then
    return
  fi

  while IFS= read -r line || [[ -n "${line}" ]]; do
    # Skip empty lines and comments
    [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue

    # Extract key and value
    if [[ "${line}" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      # Remove surrounding quotes if present
      if [[ "${value}" =~ ^\"(.*)\"$ ]] || [[ "${value}" =~ ^\'(.*)\'$ ]]; then
        value="${BASH_REMATCH[1]}"
      fi

      # Output properly quoted assignment
      printf '%s=%q\n' "${key}" "${value}"
    fi
  done < "${env_file}"
}

# -----------------------------------------------------------------------------
# Function: parse_procfile
# Description: Parses Procfile and returns process definitions
# Returns: Lines in format "process_name:command"
# -----------------------------------------------------------------------------
parse_procfile() {
  local procfile="$1"

  if [[ ! -f "${procfile}" ]]; then
    return 1
  fi

  while IFS= read -r line || [[ -n "${line}" ]]; do
    # Skip empty lines and comments
    [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue

    # Parse "process_name: command"
    if [[ "${line}" =~ ^([a-zA-Z][a-zA-Z0-9_-]*)[[:space:]]*:[[:space:]]*(.+)$ ]]; then
      local proc_name="${BASH_REMATCH[1]}"
      local proc_cmd="${BASH_REMATCH[2]}"
      echo "${proc_name}:${proc_cmd}"
    fi
  done < "${procfile}"
}

# -----------------------------------------------------------------------------
# Function: find_free_port
# Description: Finds a random free port
# -----------------------------------------------------------------------------
find_free_port() {
  local port
  local max_attempts=100
  local attempt=0

  # Get all ports already allocated to appmotel apps to avoid self-collision
  local allocated_ports=""
  if [[ -d "${APPS_CONFIG_DIR}" ]]; then
    allocated_ports=$(grep -h "^PORT=" "${APPS_CONFIG_DIR}"/*/metadata.conf 2>/dev/null | cut -d'=' -f2 || true)
  fi

  while [[ ${attempt} -lt ${max_attempts} ]]; do
    # Generate random port in range
    port=$((MIN_PORT + RANDOM % (MAX_PORT - MIN_PORT)))

    # Check if port is already allocated to another app
    if echo "${allocated_ports}" | grep -qw "${port}" 2>/dev/null; then
      attempt=$((attempt + 1))
      continue
    fi

    # Check if port is currently in use by any process
    if ! ss -tuln | grep -q ":${port} "; then
      echo "${port}"
      return 0
    fi

    attempt=$((attempt + 1))
  done

  die "Could not find free port after ${max_attempts} attempts"
}

# -----------------------------------------------------------------------------
# Function: update_port_in_env
# Description: Updates PORT and FLASK_PORT in .env file
# -----------------------------------------------------------------------------
update_port_in_env() {
  local env_file="$1"
  local new_port="$2"

  if [[ ! -f "${env_file}" ]]; then
    return 1
  fi

  # Update PORT if it exists
  if grep -q "^PORT=" "${env_file}"; then
    sed -i "s/^PORT=.*/PORT=${new_port}/" "${env_file}"
  fi

  # Also update FLASK_PORT if it exists (Flask apps)
  if grep -q "^FLASK_PORT=" "${env_file}"; then
    sed -i "s/^FLASK_PORT=.*/FLASK_PORT=${new_port}/" "${env_file}"
  fi
}

# -----------------------------------------------------------------------------
# Function: get_port_from_env
# Description: Extracts port from app's .env file
# Checks both config dir (preferred) and repo dir for .env
# -----------------------------------------------------------------------------
get_port_from_env() {
  local app_name="$1"
  local config_env="${APPS_CONFIG_DIR}/${app_name}/.env"
  local repo_env="${APPS_DATA_DIR}/${app_name}/repo/.env"

  # Prefer config dir .env, fall back to repo .env
  local env_file=""
  if [[ -f "${config_env}" ]] && [[ ! -L "${config_env}" ]]; then
    env_file="${config_env}"
  elif [[ -f "${repo_env}" ]]; then
    env_file="${repo_env}"
  else
    return 1
  fi

  # Look for PORT variable (priority order: PORT, FLASK_PORT, other *PORT* vars)
  local port

  # 1. Check for PORT=
  port=$(grep -E '^PORT=' "${env_file}" | head -1 | cut -d'=' -f2 | tr -d ' "'"'" || true)
  if [[ -n "${port}" ]] && [[ "${port}" =~ ^[0-9]+$ ]]; then
    echo "${port}"
    return 0
  fi

  # 2. Check for FLASK_PORT= (common in Flask apps)
  port=$(grep -E '^FLASK_PORT=' "${env_file}" | head -1 | cut -d'=' -f2 | tr -d ' "'"'" || true)
  if [[ -n "${port}" ]] && [[ "${port}" =~ ^[0-9]+$ ]]; then
    echo "${port}"
    return 0
  fi

  # 3. Check for any other *PORT* variable (NODE_PORT, SERVER_PORT, etc.)
  port=$(grep -iE '^[A-Z_]*PORT[A-Z_]*=' "${env_file}" | head -1 | cut -d'=' -f2 | tr -d ' "'"'" || true)
  if [[ -n "${port}" ]] && [[ "${port}" =~ ^[0-9]+$ ]]; then
    echo "${port}"
    return 0
  fi

  return 1
}

# -----------------------------------------------------------------------------
# Function: save_app_metadata
# Description: Saves app metadata to config directory
# -----------------------------------------------------------------------------
save_app_metadata() {
  local app_name="$1"
  local github_url="$2"
  local branch="$3"
  local port="$4"
  local services="${5:-}"  # Optional services string (space-separated component names)
  local subdir="${6:-}"    # Optional subfolder path within repo

  local config_dir="${APPS_CONFIG_DIR}/${app_name}"
  mkdir -p "${config_dir}"

  local metadata_file="${config_dir}/metadata.conf"

  cat > "${metadata_file}" <<EOF
APP_NAME="${app_name}"
GITHUB_URL="${github_url}"
BRANCH="${branch}"
PORT="${port}"
LAST_DEPLOYMENT="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
EOF

  # Add SERVICES field if provided (for multi-component apps)
  if [[ -n "${services}" ]]; then
    echo "SERVICES=\"${services}\"" >> "${metadata_file}"
  fi

  # Add SUBDIR field if provided (for subfolder deployments)
  if [[ -n "${subdir}" ]]; then
    echo "SUBDIR=\"${subdir}\"" >> "${metadata_file}"
  fi

  log_msg "INFO" "App metadata saved"
}

# -----------------------------------------------------------------------------
# Function: setup_app_env_file
# Description: Creates physical .env in config dir and symlinks repo/.env to it
# Looks for template: .env.default, env.default, .env.example, env.example, .env.local
# For subfolder deployments, searches up directory tree for templates
# -----------------------------------------------------------------------------
setup_app_env_file() {
  local app_name="$1"
  local port="$2"
  local subdir="${3:-}"  # Optional subfolder path

  local config_dir="${APPS_CONFIG_DIR}/${app_name}"
  local config_env="${config_dir}/.env"
  local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"
  local repo_env="${repo_dir}/.env"

  # Determine the app working directory (subfolder or repo root)
  local app_dir="${repo_dir}"
  if [[ -n "${subdir}" ]]; then
    app_dir="${repo_dir}/${subdir}"
  fi
  local app_env="${app_dir}/.env"

  mkdir -p "${config_dir}"

  # If config .env already exists (from backup restore), skip creation
  if [[ -f "${config_env}" ]] && [[ ! -L "${config_env}" ]]; then
    log_msg "INFO" "Using existing .env from config: ${config_env}"
  else
    # Remove any existing symlink in config dir
    rm -f "${config_env}"

    # Look for template files - search up directory tree for subfolders
    local template_file=""
    if [[ -n "${subdir}" ]]; then
      # For subfolder deployments, search up from subfolder to repo root
      template_file=$(find_env_template_up "${app_dir}" "${repo_dir}") || true
      if [[ -n "${template_file}" ]]; then
        log_msg "INFO" "Found template at: ${template_file}"
      fi
    else
      # Standard search in repo root
      for tmpl in ".env.default" "env.default" ".env.example" "env.example" ".env.local"; do
        if [[ -f "${repo_dir}/${tmpl}" ]]; then
          template_file="${repo_dir}/${tmpl}"
          break
        fi
      done
    fi

    if [[ -n "${template_file}" ]]; then
      # Copy template to config dir
      cp "${template_file}" "${config_env}"
      log_msg "INFO" "Created .env from template: $(basename "${template_file}")"
    elif [[ -f "${app_env}" ]] && [[ ! -L "${app_env}" ]]; then
      # If app dir has a real .env file, move it to config
      mv "${app_env}" "${config_env}"
      log_msg "INFO" "Moved existing .env to config directory"
    elif [[ -f "${repo_env}" ]] && [[ ! -L "${repo_env}" ]]; then
      # Fall back to repo root .env if exists
      mv "${repo_env}" "${config_env}"
      log_msg "INFO" "Moved existing .env from repo root to config directory"
    else
      # Create empty .env with just PORT
      echo "PORT=${port}" > "${config_env}"
      log_msg "INFO" "Created new .env with PORT=${port}"
    fi
  fi

  # Ensure PORT is set in .env and override any low ports (< 10001)
  # Apps should not dictate their own ports - the PaaS assigns them
  if grep -q "^PORT=" "${config_env}" 2>/dev/null; then
    local existing_port
    existing_port=$(grep "^PORT=" "${config_env}" | cut -d'=' -f2 | tr -d ' ')
    if [[ "${existing_port}" =~ ^[0-9]+$ ]] && [[ "${existing_port}" -lt 10001 ]]; then
      log_msg "WARN" "Overriding low port ${existing_port} with assigned port ${port}"
      update_port_in_env "${config_env}" "${port}"
    fi
  else
    echo "PORT=${port}" >> "${config_env}"
  fi

  # Verify config .env exists before creating symlinks
  if [[ ! -f "${config_env}" ]]; then
    die "Failed to create symlink: config .env does not exist at ${config_env}"
  fi

  # Remove any existing .env in repo root (file or symlink)
  rm -f "${repo_env}"

  # Create symlink from repo/.env -> config/.env
  if ! ln -s "${config_env}" "${repo_env}"; then
    die "Failed to create .env symlink: ${repo_env} -> ${config_env}"
  fi
  log_msg "INFO" "Created symlink: ${repo_env} -> ${config_env}"

  # For subfolder deployments, also create symlink in the subfolder
  if [[ -n "${subdir}" ]] && [[ "${app_env}" != "${repo_env}" ]]; then
    rm -f "${app_env}"
    if ! ln -s "${config_env}" "${app_env}"; then
      die "Failed to create .env symlink: ${app_env} -> ${config_env}"
    fi
    log_msg "INFO" "Created subfolder symlink: ${app_env} -> ${config_env}"
  fi
}

# -----------------------------------------------------------------------------
# Function: load_app_metadata
# Description: Loads app metadata from config directory
# -----------------------------------------------------------------------------
load_app_metadata() {
  local app_name="$1"
  local metadata_file="${APPS_CONFIG_DIR}/${app_name}/metadata.conf"

  if [[ ! -f "${metadata_file}" ]]; then
    die "App metadata not found for '${app_name}'"
  fi

  safe_source_metadata "${metadata_file}"
}

# -----------------------------------------------------------------------------
# Function: detect_app_type
# Description: Detects application type and returns start command
# Priority: Go (if go.mod exists) > Python > Node.js > Binary
# -----------------------------------------------------------------------------
detect_app_type() {
  local repo_dir="$1"
  local -n cmd_ref=$2

  # Check for start.sh script first (component-specific startup)
  if [[ -f "${repo_dir}/start.sh" ]]; then
    cmd_ref="bash start.sh"
    return 0
  fi

  # Check Go first (highest priority when go.mod exists)
  # Priority: start.sh > Go > Python > Node.js > Binary
  if [[ -f "${repo_dir}/go.mod" ]]; then
    # Go app - binary should be in bin/ after setup_go_env runs
    if [[ -d "${repo_dir}/bin" ]] && [[ $(find "${repo_dir}/bin" -type f -executable | wc -l) -ge 1 ]]; then
      local bin_file
      # Prefer binary matching module name
      local module_name
      module_name=$(grep "^module " "${repo_dir}/go.mod" | awk '{print $2}' | xargs basename)
      if [[ -x "${repo_dir}/bin/${module_name}" ]]; then
        cmd_ref="bin/${module_name}"
      else
        bin_file=$(find "${repo_dir}/bin" -type f -executable | head -1)
        cmd_ref="bin/$(basename "${bin_file}")"
      fi
      return 0
    fi
    # Binary not built yet, will be built by setup_go_env
    local module_name
    module_name=$(grep "^module " "${repo_dir}/go.mod" | awk '{print $2}' | xargs basename)
    cmd_ref="bin/${module_name}"
    return 0
  else
    # Python app detection - check for .py files
    # (requirements.txt may be in parent directory for subfolder deployments)
    local py_file=""

    # 1. Check for app.py (most common)
    if [[ -f "${repo_dir}/app.py" ]]; then
      py_file="app.py"
    # 2. Check for main.py
    elif [[ -f "${repo_dir}/main.py" ]]; then
      py_file="main.py"
    # 3. Check for <repo_name>.py (e.g., bedbot.py for bedbot repo)
    else
      local repo_name
      repo_name=$(basename "${repo_dir}")
      # Handle "repo" directory from our clone structure
      if [[ "${repo_name}" == "repo" ]]; then
        repo_name=$(basename "$(dirname "${repo_dir}")")
      fi
      if [[ -f "${repo_dir}/${repo_name}.py" ]]; then
        py_file="${repo_name}.py"
      # 4. Check for *<repo_name>*.py pattern (e.g., my-bedbot-app.py)
      elif [[ -n "$(find "${repo_dir}" -maxdepth 1 -name "*${repo_name}*.py" -type f 2>/dev/null | head -1)" ]]; then
        py_file=$(basename "$(find "${repo_dir}" -maxdepth 1 -name "*${repo_name}*.py" -type f | head -1)")
      # 5. Check if there's exactly one .py file
      elif [[ $(find "${repo_dir}" -maxdepth 1 -name "*.py" -type f | wc -l) -eq 1 ]]; then
        py_file=$(basename "$(find "${repo_dir}" -maxdepth 1 -name "*.py" -type f | head -1)")
      fi
    fi

    if [[ -n "${py_file}" ]]; then
      cmd_ref="python3 ${py_file}"
      return 0
    fi
  fi

  # Check for Node.js app
  if [[ -f "${repo_dir}/package.json" ]]; then
    # Node.js app
    cmd_ref="npm start"
    return 0
  fi

  # Check for single executable in bin
  if [[ -d "${repo_dir}/bin" ]] && [[ $(find "${repo_dir}/bin" -type f -executable | wc -l) -eq 1 ]]; then
    local bin_file
    bin_file=$(find "${repo_dir}/bin" -type f -executable | head -1)
    cmd_ref="bin/$(basename "${bin_file}")"
    return 0
  fi

  return 1
}

# =============================================================================
# Function: detect_components
# Description: Detects multi-component app structure (frontend, backend, etc)
# Returns: Modifies array passed by name reference
# Known components: frontend, backend, api, worker, db, cache
# =============================================================================
detect_components() {
  local repo_dir="$1"
  local -n components_ref=$2  # Output array

  local known_components=("frontend" "backend" "api" "worker" "db" "cache")
  local detected=()

  # Check each known component directory (both root and src/ subdirectory)
  for component in "${known_components[@]}"; do
    local component_path=""

    # Check root level first (e.g., frontend/, backend/)
    if [[ -d "${repo_dir}/${component}" ]]; then
      component_path="${repo_dir}/${component}"
    # Then check src/ subdirectory (e.g., src/frontend/, src/backend/)
    elif [[ -d "${repo_dir}/src/${component}" ]]; then
      component_path="${repo_dir}/src/${component}"
    fi

    # Check if component directory exists and has app markers
    if [[ -n "${component_path}" ]]; then
      if [[ -f "${component_path}/package.json" ]] || \
         [[ -f "${component_path}/requirements.txt" ]] || \
         [[ -f "${component_path}/pyproject.toml" ]] || \
         [[ -f "${component_path}/go.mod" ]]; then
        detected+=("${component}")
      fi
    fi
  done

  # Return detected components
  components_ref=("${detected[@]}")
}

# =============================================================================
# Function: get_all_services
# Description: Returns all services for an app from metadata SERVICES field
# Returns: Modifies array passed by name reference
# Fallback: If SERVICES not set, assumes single app for backward compatibility
# =============================================================================
get_all_services() {
  local app_name="$1"
  local -n services_ref=$2  # Output array

  local metadata_file="${APPS_CONFIG_DIR}/${app_name}/metadata.conf"

  if [[ ! -f "${metadata_file}" ]]; then
    services_ref=()
    return 1
  fi

  # Load SERVICES field from metadata (space-separated component names)
  local services_str
  services_str=$(grep "^SERVICES=" "${metadata_file}" 2>/dev/null | cut -d'=' -f2 | tr -d '"' || true)

  if [[ -n "${services_str}" ]]; then
    # Convert space-separated to array (temporarily use default IFS for splitting)
    local saved_ifs="${IFS}"
    IFS=' '
    read -ra services_ref <<< "${services_str}"
    IFS="${saved_ifs}"
  else
    # Fallback for single-component apps (backward compatibility)
    # Apps without SERVICES field use the app name as single service
    services_ref=("${app_name}")
  fi
}

# =============================================================================
# Function: create_systemd_service
# Description: Creates systemd service for app or app component
# Parameters:
#   $1: app_name
#   $2: repo_dir (or component_dir if component specified)
#   $3: [optional] component_name (e.g., "frontend", "backend")
#   $4: [optional] component_port (internal port for backends, uses PORT from env for frontend)
# Examples:
#   create_systemd_service myapp /path/to/repo                    # Single app
#   create_systemd_service compliance /path/to/compliance/frontend # Frontend component
#   create_systemd_service compliance /path/to/compliance/backend 8001  # Backend component
# =============================================================================
create_systemd_service() {
  local app_name="$1"
  local repo_dir="$2"
  local port="$3"
  local component_name="${4:-}"  # Optional component name (e.g., "frontend", "backend")

  # Service file naming: appmotel-{app_name}[-{component_name}].service
  # Frontend gets no suffix (appmotel-<app>.service), others get suffix
  local service_name="appmotel-${app_name}"
  if [[ -n "${component_name}" ]] && [[ "${component_name}" != "frontend" ]]; then
    service_name="${service_name}-${component_name}"
  fi
  local service_file="${SYSTEMD_USER_DIR}/${service_name}.service"
  local env_file="${repo_dir}/.env"

  # Detect app type and get start command
  local start_cmd=""
  if ! detect_app_type "${repo_dir}" start_cmd; then
    die "Could not determine how to run the app. Please check app structure."
  fi

  log_msg "INFO" "Detected start command: ${start_cmd}"

  # For Python apps, find venv (may be in parent directory for subfolder deployments)
  local venv_dir=""
  local search_dir="${repo_dir}"
  local app_data_dir
  app_data_dir=$(dirname "$(dirname "${repo_dir}")")  # Go up from repo/subfolder to app_data

  while [[ -n "${search_dir}" ]] && [[ "${search_dir}" == "${app_data_dir}"* ]]; do
    if [[ -d "${search_dir}/.venv" ]]; then
      venv_dir="${search_dir}/.venv"
      break
    fi
    local parent_dir
    parent_dir=$(dirname "${search_dir}")
    if [[ "${parent_dir}" == "${search_dir}" ]]; then
      break
    fi
    search_dir="${parent_dir}"
  done

  # For Python apps, use the venv python directly
  # Only apply if start_cmd actually uses python3 (not for Go/Node apps with requirements.txt)
  if [[ "${start_cmd}" == *"python3"* ]] && [[ -n "${venv_dir}" ]] && [[ -f "${venv_dir}/bin/python3" ]]; then
    # Replace python3 with full path to venv python
    start_cmd="${start_cmd/python3/${venv_dir}\/bin\/python3}"
    log_msg "INFO" "Using virtual environment Python: ${start_cmd}"
  elif [[ -n "${venv_dir}" ]] && [[ -f "${venv_dir}/bin/python3" ]]; then
    # Python venv exists - PATH will be set in service file
    log_msg "INFO" "Virtual environment detected at: ${venv_dir}"
  fi

  # Build environment file directive
  local env_directive=""
  if [[ -f "${env_file}" ]]; then
    env_directive="EnvironmentFile=${env_file}"
  fi

  # Get resource limits from .env or use defaults
  local memory_limit="${DEFAULT_MEMORY_LIMIT}"
  local cpu_quota="${DEFAULT_CPU_QUOTA}"

  if [[ -f "${env_file}" ]]; then
    # Parse env file for resource overrides
    local parsed_env
    parsed_env=$(parse_env_file "${env_file}")
    if echo "${parsed_env}" | grep -q "^MEMORY_LIMIT="; then
      memory_limit=$(echo "${parsed_env}" | grep "^MEMORY_LIMIT=" | cut -d= -f2-)
    fi
    if echo "${parsed_env}" | grep -q "^CPU_QUOTA="; then
      cpu_quota=$(echo "${parsed_env}" | grep "^CPU_QUOTA=" | cut -d= -f2-)
    fi
  fi

  # Build description with optional component
  local description="Appmotel Application: ${app_name}"
  if [[ -n "${component_name}" ]]; then
    description="${description} (${component_name})"
  fi

  # For Python apps with venv, add PATH to include venv bin
  local path_directive=""
  if [[ -n "${venv_dir}" ]] && [[ -f "${venv_dir}/bin/python3" ]]; then
    path_directive="Environment=\"PATH=${venv_dir}/bin:/usr/local/bin:/usr/bin:/bin\""
  fi

  cat > "${service_file}" <<EOF
[Unit]
Description=${description}
After=network-online.target

[Service]
Type=simple
WorkingDirectory=${repo_dir}
${env_directive}
${path_directive}
Environment="PORT=${port}"
Environment="HOME=${APPMOTEL_HOME}"
Environment="USER=appmotel"
ExecStart=/bin/bash -c '${start_cmd}'
Restart=always
RestartSec=10

# Resource limits
MemoryMax=${memory_limit}
CPUQuota=${cpu_quota}

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=default.target
EOF

  # Ensure XDG_RUNTIME_DIR is set
  export XDG_RUNTIME_DIR="/run/user/$(id -u)"

  systemctl --user daemon-reload
  log_msg "INFO" "Systemd user service created: ${service_name}"
}

# -----------------------------------------------------------------------------
# Function: create_systemd_service_procfile
# Description: Creates systemd service for a Procfile process
# -----------------------------------------------------------------------------
create_systemd_service_procfile() {
  local app_name="$1"
  local proc_name="$2"
  local repo_dir="$3"
  local port="$4"
  local start_cmd="$5"

  local service_file="${SYSTEMD_USER_DIR}/appmotel-${app_name}-${proc_name}.service"
  local env_file="${repo_dir}/.env"

  # For Python apps, use the venv python directly
  # Only apply if start_cmd actually uses python (not for Go/Node apps)
  if [[ "${start_cmd}" == *"python"* ]] && [[ -f "${repo_dir}/.venv/bin/python3" ]]; then
    start_cmd="${start_cmd/python3/${repo_dir}\/.venv\/bin\/python3}"
    start_cmd="${start_cmd/python /${repo_dir}\/.venv\/bin\/python3 }"
  fi

  # Build environment file directive
  local env_directive=""
  if [[ -f "${env_file}" ]]; then
    env_directive="EnvironmentFile=${env_file}"
  fi

  # Get resource limits
  local memory_limit="${DEFAULT_MEMORY_LIMIT}"
  local cpu_quota="${DEFAULT_CPU_QUOTA}"

  if [[ -f "${env_file}" ]]; then
    local parsed_env
    parsed_env=$(parse_env_file "${env_file}")
    if echo "${parsed_env}" | grep -q "^MEMORY_LIMIT="; then
      memory_limit=$(echo "${parsed_env}" | grep "^MEMORY_LIMIT=" | cut -d= -f2-)
    fi
    if echo "${parsed_env}" | grep -q "^CPU_QUOTA="; then
      cpu_quota=$(echo "${parsed_env}" | grep "^CPU_QUOTA=" | cut -d= -f2-)
    fi
  fi

  cat > "${service_file}" <<EOF
[Unit]
Description=Appmotel Application: ${app_name} (${proc_name})
After=network-online.target

[Service]
Type=simple
WorkingDirectory=${repo_dir}
${env_directive}
Environment="PORT=${port}"
Environment="HOME=${APPMOTEL_HOME}"
Environment="USER=appmotel"
ExecStart=/bin/bash -c '${start_cmd}'
Restart=always
RestartSec=10

# Resource limits
MemoryMax=${memory_limit}
CPUQuota=${cpu_quota}

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=default.target
EOF

  systemctl --user daemon-reload
  log_msg "INFO" "Systemd service created: appmotel-${app_name}-${proc_name}"
}

# -----------------------------------------------------------------------------
# Function: create_traefik_config
# Description: Creates Traefik dynamic configuration for app
# -----------------------------------------------------------------------------
create_traefik_config() {
  local app_name="$1"
  local port="$2"
  local base_domain="${3:-apps.example.edu}"
  local repo_dir="${4:-}"

  local config_file="${TRAEFIK_DYNAMIC_DIR}/${app_name}.yaml"
  local app_url="${app_name}.${base_domain}"

  # Get rate limit settings from .env or use defaults
  local rate_limit_avg="${DEFAULT_RATE_LIMIT_AVG}"
  local rate_limit_burst="${DEFAULT_RATE_LIMIT_BURST}"
  local health_check_path=""  # No health check by default - only if app explicitly sets it
  local enable_rate_limit="true"

  if [[ -n "${repo_dir}" ]] && [[ -f "${repo_dir}/.env" ]]; then
    local parsed_env
    parsed_env=$(parse_env_file "${repo_dir}/.env")
    if echo "${parsed_env}" | grep -q "^RATE_LIMIT_AVG="; then
      rate_limit_avg=$(echo "${parsed_env}" | grep "^RATE_LIMIT_AVG=" | cut -d= -f2-)
    fi
    if echo "${parsed_env}" | grep -q "^RATE_LIMIT_BURST="; then
      rate_limit_burst=$(echo "${parsed_env}" | grep "^RATE_LIMIT_BURST=" | cut -d= -f2-)
    fi
    if echo "${parsed_env}" | grep -q "^HEALTH_CHECK_PATH="; then
      health_check_path=$(echo "${parsed_env}" | grep "^HEALTH_CHECK_PATH=" | cut -d= -f2-)
    fi
    if echo "${parsed_env}" | grep -q "^DISABLE_RATE_LIMIT="; then
      enable_rate_limit="false"
    fi
  fi

  # Build middleware list
  local middlewares_line=""
  if [[ "${enable_rate_limit}" == "true" ]]; then
    middlewares_line="middlewares:
        - ${app_name}-ratelimit"
  fi

  # Build health check section (only if explicitly configured)
  local health_check_section=""
  if [[ -n "${health_check_path}" ]]; then
    health_check_section="healthCheck:
          path: ${health_check_path}
          interval: 30s
          timeout: 5s"
  fi

  cat > "${config_file}" <<EOF
http:
  routers:
    ${app_name}:
      rule: "Host(\`${app_url}\`)"
      entryPoints:
        - websecure
      service: ${app_name}
      ${middlewares_line}
      tls: {}

  services:
    ${app_name}:
      loadBalancer:
        servers:
          - url: "http://localhost:${port}"
        ${health_check_section}

  middlewares:
    ${app_name}-ratelimit:
      rateLimit:
        average: ${rate_limit_avg}
        burst: ${rate_limit_burst}
EOF

  log_msg "INFO" "Traefik config created: ${app_url} -> localhost:${port}"
}

# -----------------------------------------------------------------------------
# Function: run_install_script
# Description: Runs app's install.sh script
# -----------------------------------------------------------------------------
run_install_script() {
  local repo_dir="$1"
  local install_script="${repo_dir}/install.sh"

  if [[ ! -f "${install_script}" ]]; then
    log_msg "WARN" "No install.sh found in repository, skipping installation steps"
    return 0
  fi

  if [[ ! -x "${install_script}" ]]; then
    chmod +x "${install_script}"
  fi

  log_msg "INFO" "Running install.sh"

  safe_cd "${repo_dir}" "running install.sh"

  if bash "${install_script}"; then
    log_msg "INFO" "Installation completed successfully"
    return 0
  else
    log_msg "ERROR" "Installation script failed"
    return 1
  fi
}

# -----------------------------------------------------------------------------
# Function: setup_python_env
# Description: Sets up Python virtual environment
# -----------------------------------------------------------------------------
setup_python_env() {
  local repo_dir="$1"

  if [[ ! -f "${repo_dir}/requirements.txt" ]]; then
    return 0
  fi

  log_msg "INFO" "Setting up Python virtual environment"

  safe_cd "${repo_dir}" "setting up Python environment"

  if [[ ! -d ".venv" ]]; then
    python3 -m venv .venv
  fi

  source .venv/bin/activate
  pip install --upgrade pip
  pip install -r requirements.txt

  log_msg "INFO" "Python dependencies installed"
}

# -----------------------------------------------------------------------------
# Function: setup_nodejs_env
# Description: Sets up Node.js environment
# -----------------------------------------------------------------------------
setup_nodejs_env() {
  local repo_dir="$1"

  if [[ ! -f "${repo_dir}/package.json" ]]; then
    return 0
  fi

  log_msg "INFO" "Installing Node.js dependencies"

  safe_cd "${repo_dir}" "setting up Node.js environment"
  npm install

  # Check if this is a Next.js app with static export
  local nextjs_config=""
  if [[ -f "${repo_dir}/next.config.js" ]]; then
    nextjs_config="${repo_dir}/next.config.js"
  elif [[ -f "${repo_dir}/next.config.mjs" ]]; then
    nextjs_config="${repo_dir}/next.config.mjs"
  fi

  if [[ -n "${nextjs_config}" ]]; then
    # Check if output: 'export' is configured
    if grep -q "output.*['\"]export['\"]" "${nextjs_config}" 2>/dev/null; then
      log_msg "INFO" "Detected Next.js static export - building application"

      # Build the static export
      npm run build

      # Install serve for static hosting
      npm install serve

      # Update package.json start script to use serve
      if command -v jq &> /dev/null; then
        # Use jq if available (more robust)
        local tmp_file
        tmp_file=$(create_temp_file "package_json")
        jq '.scripts.start = "serve -l ${PORT:-3000} out"' "${repo_dir}/package.json" > "${tmp_file}"
        mv "${tmp_file}" "${repo_dir}/package.json"
      else
        # Fallback to npm pkg set
        npm pkg set scripts.start="serve -l \${PORT:-3000} out"
      fi

      log_msg "INFO" "Next.js static export built successfully"
    fi
  fi

  # Check if this is a Vite app that needs building
  if [[ -f "${repo_dir}/vite.config.ts" ]] || [[ -f "${repo_dir}/vite.config.js" ]]; then
    if grep -q '"build".*vite build' "${repo_dir}/package.json"; then
      log_msg "INFO" "Detected Vite app - building for production"

      # Build the app
      npm run build

      # Install serve for static hosting
      npm install serve

      # Add/update start script that serves the dist folder
      if command -v jq &> /dev/null; then
        local tmp_file
        tmp_file=$(create_temp_file "package_json")
        jq '.scripts.start = "serve -l ${PORT:-3000} dist"' "${repo_dir}/package.json" > "${tmp_file}"
        mv "${tmp_file}" "${repo_dir}/package.json"
      else
        npm pkg set scripts.start="serve -l \${PORT:-3000} dist"
      fi

      log_msg "INFO" "Vite app built successfully"
    fi
  fi

  log_msg "INFO" "Node.js dependencies installed"
}

# -----------------------------------------------------------------------------
# Function: setup_go_env
# Description: Sets up Go environment and builds the application
# -----------------------------------------------------------------------------
setup_go_env() {
  local repo_dir="$1"

  if [[ ! -f "${repo_dir}/go.mod" ]]; then
    return 0
  fi

  # Check if go is installed
  if ! command -v go &>/dev/null; then
    die "Go is not installed. Please install Go to deploy Go applications.
    Ubuntu/Debian: sudo apt-get install golang-go
    RHEL/CentOS:   sudo dnf install golang"
  fi

  log_msg "INFO" "Building Go application"

  safe_cd "${repo_dir}" "building Go application"

  # Download dependencies
  log_msg "INFO" "Downloading Go dependencies"
  go mod download

  # Build the application
  # Try to find the module name from go.mod for the binary name
  local module_name
  module_name=$(grep "^module " go.mod | awk '{print $2}' | xargs basename)

  # Build into bin directory
  mkdir -p "${repo_dir}/bin"

  # Check for cmd/ directory structure (common Go project layout)
  if [[ -d "${repo_dir}/cmd" ]]; then
    # Build all commands in cmd/ directory
    local cmd_count=0
    for cmd_dir in "${repo_dir}/cmd"/*; do
      if [[ -d "${cmd_dir}" ]] && [[ -f "${cmd_dir}/main.go" ]]; then
        local cmd_name
        cmd_name=$(basename "${cmd_dir}")
        log_msg "INFO" "Compiling Go binary: ${cmd_name}"
        if go build -o "${repo_dir}/bin/${cmd_name}" "${cmd_dir}"; then
          chmod +x "${repo_dir}/bin/${cmd_name}"
          log_msg "INFO" "Built: bin/${cmd_name}"
          cmd_count=$((cmd_count + 1))
        else
          log_msg "WARN" "Failed to build ${cmd_name}"
        fi
      fi
    done
    if [[ ${cmd_count} -eq 0 ]]; then
      die "No Go commands found in cmd/ directory"
    fi
    log_msg "INFO" "Go application built successfully (${cmd_count} binaries)"
  else
    # Try to build from root directory
    log_msg "INFO" "Compiling Go binary: ${module_name}"
    if go build -o "${repo_dir}/bin/${module_name}" .; then
      chmod +x "${repo_dir}/bin/${module_name}"
      log_msg "INFO" "Go application built successfully: bin/${module_name}"
    else
      die "Failed to build Go application"
    fi
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_add
# Description: Adds a new app
# Supports subfolder URLs: https://github.com/user/repo/tree/branch/path/to/folder
# -----------------------------------------------------------------------------
cmd_add() {
  if [[ $# -lt 2 ]]; then
    die "Usage: appmo add <app-name> <github-url|user/repo> [branch]"
  fi

  local app_name="$1"
  local github_url="$2"
  local branch="${3:-}"
  local subdir=""

  # Validate app name first
  validate_app_name "${app_name}"

  # Parse the URL to extract repo, branch, and subfolder
  parse_github_url "${github_url}"

  # Use parsed values
  local clone_url="${PARSED_REPO_URL}"
  local url_branch="${PARSED_BRANCH}"
  local url_subdir="${PARSED_SUBDIR}"

  # Handle branch resolution
  if [[ -n "${url_branch}" ]] && [[ -n "${branch}" ]]; then
    # Both URL contains branch AND user passed branch argument - error
    die "Conflicting branch specification: URL contains branch '${url_branch}' but you also specified '${branch}'. Remove the branch argument or use a simpler URL format."
  elif [[ -n "${url_branch}" ]]; then
    # Use branch from URL
    branch="${url_branch}"
    log_msg "INFO" "Using branch from URL: ${branch}"
  elif [[ -z "${branch}" ]]; then
    # No branch specified anywhere - default to main
    branch="main"
  fi

  # Use subfolder from URL if present
  if [[ -n "${url_subdir}" ]]; then
    subdir="${url_subdir}"
    log_msg "INFO" "Deploying from subfolder: ${subdir}"
  fi

  # Update github_url to the clean repo URL for cloning
  github_url="${clone_url}"

  # Validate the clean URL and branch
  validate_github_url "${github_url}"
  validate_branch_name "${branch}"

  # Auto-expand short GitHub URLs (e.g., "user/repo" -> "https://github.com/user/repo")
  if [[ ! "${github_url}" =~ ^(https?://|git@) ]] && [[ "${github_url}" =~ ^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$ ]]; then
    github_url="https://github.com/${github_url}"
    log_msg "INFO" "Expanded to: ${github_url}"
  fi

  if app_exists "${app_name}"; then
    die "App '${app_name}' already exists"
  fi

  log_msg "INFO" "Adding app: ${app_name}"

  # Check disk space before cloning (require at least 500MB)
  check_disk_space "${APPS_DATA_DIR}" 500

  # Create directories
  local app_data_dir="${APPS_DATA_DIR}/${app_name}"
  local repo_dir="${app_data_dir}/repo"

  mkdir -p "${app_data_dir}"

  # Clone or update repository
  if [[ -d "${repo_dir}/.git" ]]; then
    # Repo exists, pull latest changes
    log_msg "INFO" "Repository exists, pulling latest: ${github_url}"
    safe_cd "${repo_dir}" "updating git repository"
    local git_update_failed=false

    # Try to update existing repo with proper error recovery
    if ! git_with_timeout fetch origin 2>&1; then
      log_msg "WARN" "Git fetch failed"
      git_update_failed=true
    elif ! git checkout "${branch}" 2>&1; then
      log_msg "WARN" "Git checkout failed for branch '${branch}'"
      git_update_failed=true
    elif ! git reset --hard "origin/${branch}" 2>&1; then
      # Use reset --hard instead of pull to avoid merge conflicts
      log_msg "WARN" "Git reset failed"
      git_update_failed=true
    fi

    if [[ "${git_update_failed}" == "true" ]]; then
      log_msg "WARN" "Git update failed, removing and re-cloning"
      safe_cd "${APPS_DATA_DIR}" "before deleting repo"  # Move out of repo dir before deleting
      safe_rm_rf "${repo_dir}" "cmd_add re-clone"
      if ! git_with_timeout clone --branch "${branch}" "${github_url}" "${repo_dir}"; then
        safe_rm_rf "${app_data_dir}" "cmd_add clone failed"
        die "Failed to clone repository: ${github_url}"
      fi
    fi
  elif [[ -d "${repo_dir}" ]]; then
    # Directory exists but not a git repo, remove and clone
    log_msg "WARN" "Directory exists but not a git repo, removing"
    safe_rm_rf "${repo_dir}" "cmd_add non-git dir"
    log_msg "INFO" "Cloning repository: ${github_url}"
    if ! git_with_timeout clone --branch "${branch}" "${github_url}" "${repo_dir}"; then
      safe_rm_rf "${app_data_dir}" "cmd_add clone failed"
      die "Failed to clone repository: ${github_url}"
    fi
  else
    # Fresh clone
    log_msg "INFO" "Cloning repository: ${github_url}"
    if ! git_with_timeout clone --branch "${branch}" "${github_url}" "${repo_dir}"; then
      safe_rm_rf "${app_data_dir}" "cmd_add clone failed"
      die "Failed to clone repository: ${github_url}"
    fi
  fi

  # Determine the app working directory (subfolder or repo root)
  local app_dir="${repo_dir}"
  if [[ -n "${subdir}" ]]; then
    app_dir="${repo_dir}/${subdir}"
    # Verify subfolder exists
    if [[ ! -d "${app_dir}" ]]; then
      safe_rm_rf "${app_data_dir}" "subfolder not found"
      die "Subfolder '${subdir}' not found in repository. Available directories: $(ls -d "${repo_dir}"/*/ 2>/dev/null | xargs -n1 basename 2>/dev/null | tr '\n' ' ' || echo 'none')"
    fi
    log_msg "INFO" "Using subfolder: ${app_dir}"
  fi

  # Check for existing .env backup and offer to restore
  local config_dir="${APPS_CONFIG_DIR}/${app_name}"
  local env_backup="${config_dir}/.env.backup"
  if [[ -f "${env_backup}" ]]; then
    printf "Found previous .env backup for '${app_name}'. Restore it? [Y/n] "
    read -r restore_answer
    case "${restore_answer}" in
      [nN]|[nN][oO])
        log_msg "INFO" "Starting with fresh .env"
        rm -f "${env_backup}"
        ;;
      *)
        log_msg "INFO" "Restoring .env from backup"
        mkdir -p "${config_dir}"
        mv "${env_backup}" "${config_dir}/.env"
        ;;
    esac
  fi

  # Determine port (check config .env first, then repo .env, then assign new)
  local port
  local port_from_env=""
  if port_from_env=$(get_port_from_env "${app_name}"); then
    # Check if port is too low (< 10001) - override with high port
    if [[ "${port_from_env}" -lt 10001 ]]; then
      log_msg "WARN" "Port ${port_from_env} from .env is too low, assigning high port"
      port=$(find_free_port)
      log_msg "INFO" "Assigned new port: ${port}"
      # Update the .env file with new port if it exists
      local config_env="${APPS_CONFIG_DIR}/${app_name}/.env"
      if [[ -f "${config_env}" ]]; then
        update_port_in_env "${config_env}" "${port}"
      fi
    # Check if the port from .env is still free
    elif ss -tuln | grep -q ":${port_from_env} "; then
      log_msg "WARN" "Port ${port_from_env} from .env is already in use"
      port=$(find_free_port)
      log_msg "INFO" "Assigned new port: ${port}"
      # Update the .env file with new port if it exists
      local config_env="${APPS_CONFIG_DIR}/${app_name}/.env"
      if [[ -f "${config_env}" ]]; then
        update_port_in_env "${config_env}" "${port}"
      fi
    else
      port="${port_from_env}"
      log_msg "INFO" "Using port from .env: ${port}"
    fi
  else
    port=$(find_free_port)
    log_msg "INFO" "Assigned port: ${port}"
  fi

  # Setup .env file (physical in config dir, symlink in repo and subfolder)
  setup_app_env_file "${app_name}" "${port}" "${subdir}"

  # Detect multi-component structure (frontend, backend, api, etc.)
  # For subfolder deployments, detect components within the subfolder
  local -a detected_components
  detect_components "${app_dir}" detected_components

  local services_to_deploy=()

  if [[ ${#detected_components[@]} -gt 1 ]]; then
    # Multi-component app detected
    log_msg "INFO" "Detected multi-component app: ${detected_components[*]}"
    services_to_deploy=("${detected_components[@]}")
  else
    # Single-component app - detect type and setup app directory
    # For subfolder deployments, search up for dependency files
    local app_type="unknown"
    local deps_dir="${app_dir}"  # Directory containing dependency files

    if [[ -f "${app_dir}/go.mod" ]]; then
      app_type="go"
    elif [[ -f "${app_dir}/requirements.txt" ]] || [[ -f "${app_dir}/pyproject.toml" ]]; then
      app_type="python"
    elif [[ -f "${app_dir}/package.json" ]]; then
      app_type="nodejs"
    elif [[ -n "${subdir}" ]]; then
      # Subfolder deployment: search up for dependency files
      local found_dir
      if found_dir=$(find_file_up "requirements.txt" "${app_dir}" "${repo_dir}"); then
        app_type="python"
        deps_dir="${found_dir}"
        log_msg "INFO" "Found requirements.txt in parent: ${found_dir}"
      elif found_dir=$(find_file_up "pyproject.toml" "${app_dir}" "${repo_dir}"); then
        app_type="python"
        deps_dir="${found_dir}"
        log_msg "INFO" "Found pyproject.toml in parent: ${found_dir}"
      elif found_dir=$(find_file_up "package.json" "${app_dir}" "${repo_dir}"); then
        app_type="nodejs"
        deps_dir="${found_dir}"
        log_msg "INFO" "Found package.json in parent: ${found_dir}"
      elif found_dir=$(find_file_up "go.mod" "${app_dir}" "${repo_dir}"); then
        app_type="go"
        deps_dir="${found_dir}"
        log_msg "INFO" "Found go.mod in parent: ${found_dir}"
      fi
    fi

    log_msg "INFO" "Detected app type: ${app_type}"

    case "${app_type}" in
      go)
        setup_go_env "${deps_dir}" || {
          safe_rm_rf "${app_data_dir}" "Go build failed"
          die "Failed to build Go application"
        }
        ;;
      python)
        setup_python_env "${deps_dir}" || {
          safe_rm_rf "${app_data_dir}" "Python setup failed"
          die "Failed to setup Python environment"
        }
        ;;
      nodejs)
        setup_nodejs_env "${deps_dir}" || {
          safe_rm_rf "${app_data_dir}" "Node.js setup failed"
          die "Failed to setup Node.js environment"
        }
        ;;
      *)
        log_msg "WARN" "Unknown app type, skipping environment setup"
        ;;
    esac

    # Run install script for single app
    if ! run_install_script "${app_dir}"; then
      safe_rm_rf "${app_data_dir}" "install script failed"
      die "Installation failed, rolling back"
    fi

    services_to_deploy=()
  fi

  # Use BASE_DOMAIN from .env (sourced at script start) or default
  local base_domain="${BASE_DOMAIN:-apps.example.edu}"

  # Setup all detected services (multi-component or fallback to Procfile/single)
  if [[ ${#services_to_deploy[@]} -gt 0 ]]; then
    # Multi-component deployment
    log_msg "INFO" "Setting up ${#services_to_deploy[@]} components..."

    # Track services to start (backend first, then frontend)
    local -a backend_services=()
    local frontend_service=""

    for component in "${services_to_deploy[@]}"; do
      # Resolve component directory (check root level first, then src/)
      # For subfolder deployments, components are relative to app_dir
      local component_dir="${app_dir}/${component}"
      if [[ ! -d "${component_dir}" ]]; then
        component_dir="${app_dir}/src/${component}"
      fi

      local component_port="${port}"

      # Only frontend gets the public port; others run internal
      if [[ "${component}" != "frontend" ]]; then
        component_port=$(find_free_port)
        log_msg "INFO" "Assigned internal port ${component_port} for ${component}"
      fi

      log_msg "INFO" "Setting up component: ${component} at ${component_dir}"

      # Detect and setup component type
      if [[ -f "${component_dir}/go.mod" ]]; then
        setup_go_env "${component_dir}" || {
          safe_rm_rf "${app_data_dir}" "Go component build failed: ${component}"
          die "Failed to build Go component: ${component}"
        }
      elif [[ -f "${component_dir}/requirements.txt" ]] || [[ -f "${component_dir}/pyproject.toml" ]]; then
        setup_python_env "${component_dir}" || {
          safe_rm_rf "${app_data_dir}" "Python component setup failed: ${component}"
          die "Failed to setup Python component: ${component}"
        }
      elif [[ -f "${component_dir}/package.json" ]]; then
        setup_nodejs_env "${component_dir}" || {
          safe_rm_rf "${app_data_dir}" "Node.js component setup failed: ${component}"
          die "Failed to setup Node.js component: ${component}"
        }
      fi

      # Run install script if exists in component
      if [[ -f "${component_dir}/install.sh" ]]; then
        log_msg "INFO" "Running install script for ${component}"
        safe_cd "${component_dir}" "running install script for ${component}"
        if ! bash install.sh; then
          safe_rm_rf "${app_data_dir}" "component install failed: ${component}"
          die "Installation failed for component: ${component}"
        fi
      fi

      # Create systemd service for component
      # Frontend uses appmotel-<app>.service (no suffix), others get suffix
      local service_suffix=""
      if [[ "${component}" != "frontend" ]]; then
        service_suffix="-${component}"
        backend_services+=("appmotel-${app_name}${service_suffix}")
      else
        frontend_service="appmotel-${app_name}"
      fi
      create_systemd_service "${app_name}" "${component_dir}" "${component_port}" "${component}"

      # Enable service (don't start yet - we'll start in correct order)
      systemctl --user enable "appmotel-${app_name}${service_suffix}"
    done

    # Start services in correct order: backend first, then frontend
    log_msg "INFO" "Starting services (backend first, then frontend)..."
    for svc in "${backend_services[@]}"; do
      log_msg "INFO" "Starting ${svc}..."
      systemctl --user start "${svc}"
    done
    if [[ -n "${frontend_service}" ]]; then
      log_msg "INFO" "Starting ${frontend_service}..."
      systemctl --user start "${frontend_service}"
    fi

    # Create Traefik config only for frontend (public port)
    create_traefik_config "${app_name}" "${port}" "${base_domain}" "${app_dir}"

    # Save metadata with services list and subdir
    services_str=$(echo "${services_to_deploy[@]}" | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
    save_app_metadata "${app_name}" "${github_url}" "${branch}" "${port}" "${services_str}" "${subdir}"
  else
    # Single-component deployment - check for Procfile or standard single service
    local procfile="${app_dir}/Procfile"
    if [[ -f "${procfile}" ]]; then
      log_msg "INFO" "Procfile detected, setting up multi-process app"

      local proc_count=0
      while IFS= read -r proc_line; do
        if [[ "${proc_line}" =~ ^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$ ]]; then
          local proc_name="${BASH_REMATCH[1]}"
          local proc_cmd="${BASH_REMATCH[2]}"
          local proc_port="${port}"

          # Web process gets the main port, others get incremented ports
          if [[ "${proc_name}" != "web" ]]; then
            ((proc_count++))
            proc_port=$((port + proc_count))

            # Ensure port doesn't exceed maximum allowed port
            if [[ ${proc_port} -gt ${MAX_PORT} ]]; then
              die "Port overflow: Procfile has too many processes. Port ${proc_port} exceeds maximum ${MAX_PORT}"
            fi
          fi

          log_msg "INFO" "Creating service for process: ${proc_name} (port ${proc_port})"
          create_systemd_service_procfile "${app_name}" "${proc_name}" "${app_dir}" "${proc_port}" "${proc_cmd}"

          # Enable and start service
          systemctl --user enable "appmotel-${app_name}-${proc_name}"
          systemctl --user start "appmotel-${app_name}-${proc_name}"
        fi
      done < <(parse_procfile "${procfile}")

      # Create Traefik config (only routes to web process on main port)
      create_traefik_config "${app_name}" "${port}" "${base_domain}" "${app_dir}"
    else
      # Single process app
      create_systemd_service "${app_name}" "${app_dir}" "${port}"

      # Create Traefik config with app_dir for settings
      create_traefik_config "${app_name}" "${port}" "${base_domain}" "${app_dir}"

      # Start service
      systemctl --user enable "appmotel-${app_name}"
      systemctl --user start "appmotel-${app_name}"
    fi

    # Save metadata (no SERVICES field for single-component, but include subdir)
    save_app_metadata "${app_name}" "${github_url}" "${branch}" "${port}" "" "${subdir}"
  fi

  local app_url="https://${app_name}.${base_domain}"

  log_msg "INFO" "App '${app_name}' added successfully"
  log_msg "INFO" "URL: ${app_url}"
  log_msg "INFO" "Status: appmo status ${app_name}"
  log_msg "INFO" "Logs: appmo logs ${app_name}"
  log_msg "INFO" ""

  # Check if BASE_DOMAIN is still set to default
  if [[ "${base_domain}" == "apps.example.edu" ]] || [[ "${base_domain}" == "apps.yourdomain.edu" ]]; then
    log_msg "WARN" "  BASE_DOMAIN is set to default value: ${base_domain}"
    log_msg "WARN" "   Please update BASE_DOMAIN in ~/.config/appmotel/.env"
    log_msg "WARN" "   Then restart Traefik: sudo systemctl restart traefik-appmotel"
    return
  fi

  # Check if the app URL is reachable (retry for 15 seconds)
  log_msg "INFO" "Checking if app is accessible..."

  local http_code
  local response_body
  local max_attempts=15
  local attempt=1
  local app_accessible=false

  local curl_output
  curl_output=$(create_temp_file "appmo_check")

  while [[ ${attempt} -le ${max_attempts} ]]; do
    http_code=$(curl -s -o "${curl_output}" -w '%{http_code}' --connect-timeout 2 --max-time 3 -k "${app_url}" 2>/dev/null || echo "000")
    response_body=$(cat "${curl_output}" 2>/dev/null || echo "")

    # Check for successful HTTP status (2xx or 3xx) and no "Bad Gateway" in response
    if [[ "${http_code}" =~ ^[23] ]] && ! grep -qi "bad gateway" <<< "${response_body}"; then
      app_accessible=true
      break
    fi

    # Only wait and retry if not the last attempt
    if [[ ${attempt} -lt ${max_attempts} ]]; then
      sleep 1
    fi
    ((attempt++))
  done

  if [[ "${app_accessible}" == "true" ]]; then
    log_msg "INFO" " App is accessible at ${app_url}"
  else
    if [[ "${http_code}" == "502" ]] || grep -qi "bad gateway" <<< "${response_body}"; then
      log_msg "WARN" "App not accessible - received Bad Gateway error (app may not be running on port ${port})"
    else
      log_msg "WARN" "App not yet accessible - DNS may need configuration"
    fi
    log_msg "INFO" ""
    log_msg "INFO" "DNS Configuration Required:"
    log_msg "INFO" ""
    log_msg "INFO" "   Configure DNS to route traffic to this app. Choose one option:"
    log_msg "INFO" ""
    log_msg "INFO" "   Option 1 (Recommended): Wildcard A record"
    log_msg "INFO" "     *.${base_domain} IN A $(curl -s --connect-timeout 3 ifconfig.me 2>/dev/null || echo 'YOUR_SERVER_IP')"
    log_msg "INFO" "      All subdomains automatically route to this server"
    log_msg "INFO" ""
    log_msg "INFO" "   Option 2: Individual A record"
    log_msg "INFO" "     ${app_name}.${base_domain} IN A $(curl -s --connect-timeout 3 ifconfig.me 2>/dev/null || echo 'YOUR_SERVER_IP')"
    log_msg "INFO" "      Requires manual DNS update for each new app"
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_remove
# Description: Removes an app (also aliased as 'rm')
# Backs up .env file before removal for potential restore on re-add
# -----------------------------------------------------------------------------
cmd_remove() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo remove <app-name>"
  fi

  local app_name="$1"

  require_app_exists "${app_name}"

  log_msg "INFO" "Removing app: ${app_name}"

  # Backup .env file before removal
  local config_dir="${APPS_CONFIG_DIR}/${app_name}"
  local env_file="${config_dir}/.env"
  local env_backup="${config_dir}/.env.backup"

  if [[ -f "${env_file}" ]] && [[ ! -L "${env_file}" ]]; then
    # Create config dir if needed (for storing backup)
    mkdir -p "${config_dir}"
    cp "${env_file}" "${env_backup}"
    log_msg "INFO" "Backed up .env to ${env_backup}"
  fi

  # Get all services for this app (handles multi-component and Procfile)
  local -a services
  get_all_services "${app_name}" services

  # Stop, disable, and remove all service files
  for service in "${services[@]}"; do
    local service_name
    # Frontend gets no suffix, others get suffix
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi

    # Stop and disable service
    systemctl_stop "${service_name}"
    systemctl --user disable "${service_name}" 2>/dev/null || true

    # Remove service file
    rm -f "${SYSTEMD_USER_DIR}/${service_name}.service"
  done
  systemctl --user daemon-reload

  # Remove Traefik config
  rm -f "${TRAEFIK_DYNAMIC_DIR}/${app_name}.yaml"

  # Remove app data
  safe_rm_rf "${APPS_DATA_DIR}/${app_name}" "cmd_remove app data"

  # Remove app config (but preserve .env.backup)
  # Move .env.backup to temp, remove dir, recreate with just backup
  if [[ -f "${env_backup}" ]]; then
    local temp_backup
    temp_backup=$(create_temp_file "env_backup")
    cp "${env_backup}" "${temp_backup}"
    safe_rm_rf "${config_dir}" "cmd_remove config (preserving backup)"
    mkdir -p "${config_dir}"
    mv "${temp_backup}" "${env_backup}"
    log_msg "INFO" ".env backup preserved at ${env_backup}"
    log_msg "INFO" "Re-add app with same name to restore .env"
  else
    safe_rm_rf "${config_dir}" "cmd_remove config"
  fi

  log_msg "INFO" "App '${app_name}' removed successfully"
}

# -----------------------------------------------------------------------------
# Function: cmd_list
# Description: Lists all apps
# -----------------------------------------------------------------------------
cmd_list() {
  if [[ ! -d "${APPS_CONFIG_DIR}" ]]; then
    echo "No apps configured"
    return
  fi

  local -a apps
  # Use -print0 and mapfile -d '' for safe handling of special characters
  mapfile -t -d '' apps < <(find "${APPS_CONFIG_DIR}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
  # Extract basenames
  local -a app_names=()
  for app_path in "${apps[@]:-}"; do
    [[ -n "${app_path}" ]] && app_names+=("$(basename "${app_path}")")
  done
  apps=("${app_names[@]:-}")

  if [[ ${#apps[@]} -eq 0 ]]; then
    echo "No apps configured"
    return
  fi

  printf "%-15s %-10s %-35s %s\n" "APP NAME" "STATUS" "REPO" "URL"
  printf "%-15s %-10s %-35s %s\n" "--------" "------" "----" "---"

  local base_domain="${BASE_DOMAIN:-apps.example.edu}"

  local found_apps=0
  for app in "${apps[@]}"; do
    # Skip directories that only have .env.backup (removed apps)
    if ! app_exists "${app}"; then
      continue
    fi
    found_apps=$((found_apps + 1))

    local status="stopped"
    if systemctl --user is-active --quiet "appmotel-${app}"; then
      status="running"
    fi

    local url="https://${app}.${base_domain}"

    # Get repo from metadata (extract user/repo from GitHub URL)
    local repo=""
    local metadata_file="${APPS_CONFIG_DIR}/${app}/metadata.conf"
    if [[ -f "${metadata_file}" ]]; then
      local github_url
      github_url=$(grep "^GITHUB_URL=" "${metadata_file}" | cut -d'"' -f2)
      # Extract user/repo from URL (handles https://github.com/user/repo or git@github.com:user/repo)
      repo=$(echo "${github_url}" | sed -E 's|^https?://github\.com/||; s|^git@github\.com:||; s|\.git$||')
    fi

    printf "%-15s %-10s %-35s %s\n" "${app}" "${status}" "${repo}" "${url}"
  done

  if [[ ${found_apps} -eq 0 ]]; then
    echo "No apps configured"
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_status
# Description: Shows app status
# -----------------------------------------------------------------------------
cmd_status() {
  local base_domain="${BASE_DOMAIN:-apps.example.edu}"

  if [[ $# -eq 0 ]]; then
    # Show Traefik service status
    sudo /bin/systemctl status traefik-appmotel || true
    return
  fi

  local app_name="$1"

  require_app_exists "${app_name}"

  load_app_metadata "${app_name}"

  # Get all services for this app
  local -a services
  get_all_services "${app_name}" services

  # Show systemctl status for each service (allow failure for stopped services)
  for service in "${services[@]}"; do
    local service_name
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    systemctl --user status "${service_name}" --no-pager 2>/dev/null || true
    echo ""
  done

  echo "App: ${app_name}"
  echo "URL: https://${app_name}.${base_domain}"
  if [[ -n "${SUBDIR:-}" ]]; then
    echo "GitHub: ${GITHUB_URL} (${BRANCH}) [subfolder: ${SUBDIR}]"
  else
    echo "GitHub: ${GITHUB_URL} (${BRANCH})"
  fi
  echo "Port: ${PORT}"
  echo "Last Deployment: $(format_timestamp "${LAST_DEPLOYMENT}")"
  echo ""

  # Check status for each service/component
  echo "Service Status:"
  for service in "${services[@]}"; do
    local service_name
    local display_name="${service}"
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
      if [[ "${service}" == "${app_name}" ]]; then
        display_name="main"
      fi
    else
      service_name="appmotel-${app_name}-${service}"
    fi

    echo "  ${display_name}:"
    if systemctl --user is-active --quiet "${service_name}" 2>/dev/null; then
      echo "    Systemd: running"
    else
      echo "    Systemd: stopped"
    fi

    # Check port response for frontend only
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      if timeout 2 bash -c "cat < /dev/null > /dev/tcp/localhost/${PORT}" 2>/dev/null; then
        echo "    Port ${PORT}: responding"
      else
        echo "    Port ${PORT}: not responding"
      fi
    fi
  done
}

# -----------------------------------------------------------------------------
# Function: cmd_start
# Description: Starts an app
# -----------------------------------------------------------------------------
cmd_start() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo start <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  # Get all services for this app (handles multi-component)
  local -a services
  get_all_services "${app_name}" services

  log_msg "INFO" "Starting app: ${app_name}"
  for service in "${services[@]}"; do
    local service_name
    # Frontend gets no suffix, others get suffix
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    systemctl --user start "${service_name}"
  done
  log_msg "INFO" "App started"
}

# -----------------------------------------------------------------------------
# Function: cmd_stop
# Description: Stops an app
# -----------------------------------------------------------------------------
cmd_stop() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo stop <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  # Get all services for this app (handles multi-component)
  local -a services
  get_all_services "${app_name}" services

  log_msg "INFO" "Stopping app: ${app_name}"
  for service in "${services[@]}"; do
    local service_name
    # Frontend gets no suffix, others get suffix
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    systemctl --user stop "${service_name}"
  done
  log_msg "INFO" "App stopped"
}

# -----------------------------------------------------------------------------
# Function: cmd_restart
# Description: Restarts an app
# -----------------------------------------------------------------------------
cmd_restart() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo restart <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  # Get all services for this app (handles multi-component)
  local -a services
  get_all_services "${app_name}" services

  log_msg "INFO" "Restarting app: ${app_name}"
  for service in "${services[@]}"; do
    local service_name
    # Frontend gets no suffix, others get suffix
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    systemctl --user restart "${service_name}"
  done
  log_msg "INFO" "App restarted"
}

# -----------------------------------------------------------------------------
# Function: cmd_update
# Description: Updates an app with automatic backup and rollback on failure
# -----------------------------------------------------------------------------
cmd_update() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo update <app-name>"
  fi

  local app_name="$1"

  require_app_exists "${app_name}"

  load_app_metadata "${app_name}"

  local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"

  # Determine app working directory (subfolder or repo root)
  local app_dir="${repo_dir}"
  if [[ -n "${SUBDIR:-}" ]]; then
    app_dir="${repo_dir}/${SUBDIR}"
    log_msg "INFO" "Using subfolder: ${SUBDIR}"
  fi

  log_msg "INFO" "Updating app: ${app_name}"

  # Create backup before update
  log_msg "INFO" "Creating backup before update..."
  local backup_id
  backup_id=$(create_backup "${app_name}")

  # Track if we need to rollback
  local update_failed=false

  # Pull latest changes
  safe_cd "${repo_dir}" "pulling latest changes"
  if ! git_with_timeout pull origin "${BRANCH}"; then
    log_msg "ERROR" "Failed to pull latest changes"
    update_failed=true
  fi

  if [[ "${update_failed}" == "false" ]]; then
    # Check if .env.default has a low port and override it
    # Apps should not dictate their own ports - the PaaS assigns them
    local config_env="${APPS_CONFIG_DIR}/${app_name}/.env"
    local env_default="${app_dir}/.env.default"

    if [[ -f "${env_default}" ]] && grep -q "^PORT=" "${env_default}" 2>/dev/null; then
      local default_port
      default_port=$(grep "^PORT=" "${env_default}" | cut -d'=' -f2 | tr -d ' ')
      if [[ "${default_port}" =~ ^[0-9]+$ ]] && [[ "${default_port}" -lt 10001 ]]; then
        # Get current port from config .env or assign new one
        local assigned_port="${PORT}"
        if [[ -z "${assigned_port}" ]] || [[ "${assigned_port}" -lt 10001 ]]; then
          assigned_port=$(find_free_port)
        fi
        log_msg "WARN" "App's .env.default has low port ${default_port}, overriding with ${assigned_port}"
        update_port_in_env "${config_env}" "${assigned_port}"
        PORT="${assigned_port}"

        # Update Traefik config with new port
        local base_domain="${BASE_DOMAIN:-apps.example.com}"
        create_traefik_config "${app_name}" "${assigned_port}" "${base_domain}" "${app_dir}"
      fi
    fi

    # Get all services for this app
    local -a services
    get_all_services "${app_name}" services

    # Check if multi-component app
    if [[ ${#services[@]} -gt 1 ]] && [[ "${services[0]}" != "${app_name}" ]]; then
      # Multi-component: setup each component
      log_msg "INFO" "Updating ${#services[@]} components..."
      for component in "${services[@]}"; do
        # Resolve component directory (check root level first, then src/)
        # For subfolder deployments, components are relative to app_dir
        local component_dir="${app_dir}/${component}"
        if [[ ! -d "${component_dir}" ]]; then
          component_dir="${app_dir}/src/${component}"
        fi
        log_msg "INFO" "Updating component: ${component} at ${component_dir}"

        # Setup component environment
        if [[ -f "${component_dir}/go.mod" ]]; then
          setup_go_env "${component_dir}" || update_failed=true
        elif [[ -f "${component_dir}/requirements.txt" ]] || [[ -f "${component_dir}/pyproject.toml" ]]; then
          setup_python_env "${component_dir}" || update_failed=true
        elif [[ -f "${component_dir}/package.json" ]]; then
          setup_nodejs_env "${component_dir}" || update_failed=true
        fi

        # Run component install script
        if [[ -f "${component_dir}/install.sh" ]]; then
          safe_cd "${component_dir}" "running install.sh for ${component}"
          if ! bash install.sh; then
            log_msg "ERROR" "Install script failed for ${component}"
            update_failed=true
          fi
        fi
      done
    else
      # Single-component: setup app directory
      # For subfolder deployments, search up for dependency files
      local deps_dir="${app_dir}"
      if [[ -n "${SUBDIR:-}" ]]; then
        local found_dir
        if found_dir=$(find_file_up "requirements.txt" "${app_dir}" "${repo_dir}"); then
          deps_dir="${found_dir}"
        elif found_dir=$(find_file_up "pyproject.toml" "${app_dir}" "${repo_dir}"); then
          deps_dir="${found_dir}"
        elif found_dir=$(find_file_up "package.json" "${app_dir}" "${repo_dir}"); then
          deps_dir="${found_dir}"
        elif found_dir=$(find_file_up "go.mod" "${app_dir}" "${repo_dir}"); then
          deps_dir="${found_dir}"
        fi
      fi

      setup_python_env "${deps_dir}"
      setup_nodejs_env "${deps_dir}"
      setup_go_env "${deps_dir}"

      # Run install script
      if ! run_install_script "${app_dir}"; then
        log_msg "ERROR" "Install script failed"
        update_failed=true
      fi
    fi
  fi

  if [[ "${update_failed}" == "true" ]]; then
    log_msg "WARN" "Update failed, rolling back to backup ${backup_id}..."
    if restore_backup "${app_name}" "${backup_id}"; then
      log_msg "INFO" "Rollback completed. App restored to previous version."
    else
      log_msg "ERROR" "Rollback failed! App may be in inconsistent state."
      log_msg "ERROR" "Manual intervention required. Backup available at: ${BACKUPS_DIR}/${app_name}/${backup_id}"
    fi
    return 1
  fi

  # Get SERVICES string if multi-component
  local services_str=""
  if [[ ${#services[@]} -gt 1 ]] && [[ "${services[0]}" != "${app_name}" ]]; then
    services_str=$(echo "${services[@]}" | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
  fi

  # Update metadata timestamp (preserve SUBDIR if set)
  save_app_metadata "${app_name}" "${GITHUB_URL}" "${BRANCH}" "${PORT}" "${services_str}" "${SUBDIR:-}"

  # Restart all services
  log_msg "INFO" "Restarting services..."
  for service in "${services[@]}"; do
    local service_name
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    systemctl --user restart "${service_name}"
  done

  log_msg "INFO" "App updated successfully (backup: ${backup_id})"
}

# -----------------------------------------------------------------------------
# Function: cmd_logs
# Description: Shows app logs
# -----------------------------------------------------------------------------
cmd_logs() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo logs <app-name> [lines]"
  fi

  local app_name="$1"
  local lines="${2:-50}"

  require_app_exists "${app_name}"

  # Get all services for this app
  local -a services
  get_all_services "${app_name}" services

  # Build journalctl command with all service units
  local -a unit_args=()
  for service in "${services[@]}"; do
    local service_name
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    unit_args+=("-u" "${service_name}")
  done

  # Show logs from all services
  journalctl --user "${unit_args[@]}" -n "${lines}" --no-pager
}

# -----------------------------------------------------------------------------
# Function: cmd_exec
# Description: Executes command in app environment
# -----------------------------------------------------------------------------
cmd_exec() {
  if [[ $# -lt 2 ]]; then
    die "Usage: appmo exec <app-name> <command>"
  fi

  local app_name="$1"
  shift

  require_app_exists "${app_name}"

  local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"
  local env_file="${repo_dir}/.env"

  if [[ ! -d "${repo_dir}" ]]; then
    die "App repository directory not found: ${repo_dir}"
  fi

  safe_cd "${repo_dir}" "executing command in app environment"

  # Use safe_source_env to prevent command injection from malicious .env files
  if [[ -f "${env_file}" ]]; then
    safe_source_env "${env_file}"
  fi

  # Activate Python venv if it exists (venv activate scripts are trusted)
  if [[ -f "${repo_dir}/.venv/bin/activate" ]]; then
    # shellcheck source=/dev/null
    source "${repo_dir}/.venv/bin/activate"
  fi

  "$@"
}

# -----------------------------------------------------------------------------
# Function: cmd_env
# Description: Opens the app's .env file in the default editor
# The physical .env lives in config dir, repo has symlink to it
# -----------------------------------------------------------------------------
cmd_env() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo env <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  # Physical .env is in config directory
  local env_file="${APPS_CONFIG_DIR}/${app_name}/.env"
  local repo_env="${APPS_DATA_DIR}/${app_name}/repo/.env"

  if [[ ! -f "${env_file}" ]]; then
    # Create .env file if it doesn't exist
    mkdir -p "${APPS_CONFIG_DIR}/${app_name}"
    touch "${env_file}"
    log_msg "INFO" "Created new .env file: ${env_file}"
  fi

  # Ensure symlink exists in repo
  if [[ ! -L "${repo_env}" ]]; then
    rm -f "${repo_env}"
    ln -s "${env_file}" "${repo_env}"
  fi

  # Capture file hash before editing to detect changes
  local hash_before=""
  if [[ -f "${env_file}" ]]; then
    hash_before=$(md5sum "${env_file}" 2>/dev/null | awk '{print $1}')
  fi

  # Use EDITOR or VISUAL, fall back to vi
  local editor="${EDITOR:-${VISUAL:-vi}}"

  log_msg "INFO" "Opening ${env_file} with ${editor}"
  "${editor}" "${env_file}"

  # Check if file was modified
  local hash_after=""
  if [[ -f "${env_file}" ]]; then
    hash_after=$(md5sum "${env_file}" 2>/dev/null | awk '{print $1}')
  fi

  if [[ "${hash_before}" != "${hash_after}" ]]; then
    log_msg "INFO" "Environment file changed"
    # Ask user if they want to restart
    printf "Restart app to apply changes? [Y/n] "
    read -r answer
    case "${answer}" in
      [nN]|[nN][oO])
        log_msg "INFO" "Skipping restart. Run 'appmo restart ${app_name}' to apply changes later."
        ;;
      *)
        cmd_restart "${app_name}"
        ;;
    esac
  else
    log_msg "INFO" "No changes detected"
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_backup
# Description: Creates a backup of an app
# -----------------------------------------------------------------------------
cmd_backup() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo backup <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  log_msg "INFO" "Creating backup for app: ${app_name}"
  local backup_id
  backup_id=$(create_backup "${app_name}")
  log_msg "INFO" "Backup created successfully: ${backup_id}"
}

# -----------------------------------------------------------------------------
# Function: cmd_restore
# Description: Restores an app from a backup
# -----------------------------------------------------------------------------
cmd_restore() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo restore <app-name> [backup-id]"
  fi

  local app_name="$1"
  local backup_id="${2:-}"

  require_app_exists "${app_name}"

  # If no backup-id provided, use the most recent
  if [[ -z "${backup_id}" ]]; then
    local backup_base="${BACKUPS_DIR}/${app_name}"
    if [[ ! -d "${backup_base}" ]]; then
      die "No backups found for app '${app_name}'"
    fi
    backup_id=$(ls -t "${backup_base}" | head -1)
    if [[ -z "${backup_id}" ]]; then
      die "No backups found for app '${app_name}'"
    fi
    log_msg "INFO" "Using most recent backup: ${backup_id}"
  fi

  if ! restore_backup "${app_name}" "${backup_id}"; then
    die "Restore failed - check logs for details"
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_backups
# Description: Lists available backups for an app
# -----------------------------------------------------------------------------
cmd_backups() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo backups <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  list_backups "${app_name}"
}

# -----------------------------------------------------------------------------
# Function: cmd_check
# Description: Check for available updates without deploying
# -----------------------------------------------------------------------------
cmd_check() {
  local filter_app="${1:-}"

  # Check if apps directory exists
  if [[ ! -d "${APPS_CONFIG_DIR}" ]]; then
    echo "No apps configured yet"
    return 0
  fi

  # If specific app requested, verify it exists
  if [[ -n "${filter_app}" ]]; then
    require_app_exists "${filter_app}"
  fi

  local updates_available=0
  local app_count=0

  printf "%-15s %-12s %-10s %s\n" "APP" "STATUS" "LOCAL" "REMOTE"
  printf "%-15s %-12s %-10s %s\n" "---" "------" "-----" "------"

  for app_dir in "${APPS_CONFIG_DIR}"/*; do
    if [[ ! -d "${app_dir}" ]]; then
      continue
    fi

    local app_name
    app_name=$(basename "${app_dir}")

    # If filter specified, skip non-matching apps
    if [[ -n "${filter_app}" ]] && [[ "${app_name}" != "${filter_app}" ]]; then
      continue
    fi

    # Skip directories that only have .env.backup (removed apps)
    if ! app_exists "${app_name}"; then
      continue
    fi

    app_count=$((app_count + 1))

    local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"

    if [[ ! -d "${repo_dir}" ]]; then
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "NO REPO" "-" "-"
      continue
    fi

    cd "${repo_dir}" || { printf "%-15s %-12s %-10s %s\n" "${app_name}" "CD ERR" "-" "-"; continue; }

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "NOT GIT" "-" "-"
      continue
    fi

    # Fetch latest changes (quietly)
    if ! git_with_timeout fetch origin 2>/dev/null; then
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "FETCH ERR" "-" "-"
      continue
    fi

    local local_head
    local remote_head
    local_head=$(git rev-parse HEAD)

    local tracking_branch
    tracking_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")

    if [[ -z "${tracking_branch}" ]]; then
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "NO TRACK" "${local_head:0:8}" "-"
      continue
    fi

    remote_head=$(git rev-parse "${tracking_branch}")

    if [[ "${local_head}" != "${remote_head}" ]]; then
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "UPDATE" "${local_head:0:8}" "${remote_head:0:8}"
      updates_available=$((updates_available + 1))
    else
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "up-to-date" "${local_head:0:8}" "-"
    fi
  done

  echo ""
  if [[ ${app_count} -eq 0 ]]; then
    echo "No apps found"
  elif [[ ${updates_available} -eq 0 ]]; then
    echo "All ${app_count} app(s) are up to date"
  else
    echo "${updates_available} of ${app_count} app(s) have updates available"
    echo "Run 'appmo update <app>' or 'appmo autopull' to deploy"
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_autopull
# Description: Automatically checks all apps for updates and deploys them
# This is designed to run periodically via systemd timer
# -----------------------------------------------------------------------------
cmd_autopull() {
  local lockfile="${APPS_DATA_DIR}/.autopull.lock"

  # Ensure lock directory exists
  local lockdir
  lockdir=$(dirname "${lockfile}")
  mkdir -p "${lockdir}"

  # Use flock for atomic locking to prevent race conditions
  # Open lockfile on file descriptor 9
  exec 9>"${lockfile}"

  if ! flock --nonblock 9; then
    log_msg "INFO" "Another autopull instance is running, exiting"
    exit 0
  fi

  # Write PID to lockfile for debugging (lock is held by flock, not PID file)
  echo $$ >&9

  # Trap will release lock automatically when fd 9 is closed on exit
  trap 'exec 9>&-' EXIT

  log_msg "INFO" "Starting autopull check"

  # Check if apps directory exists
  if [[ ! -d "${APPS_CONFIG_DIR}" ]]; then
    log_msg "INFO" "No apps configured yet"
    exit 0
  fi

  # Get list of all apps
  local app_count=0
  local updated_count=0

  for app_dir in "${APPS_CONFIG_DIR}"/*; do
    if [[ ! -d "${app_dir}" ]]; then
      continue
    fi

    local app_name
    app_name=$(basename "${app_dir}")

    # Skip directories that only have .env.backup (removed apps)
    if ! app_exists "${app_name}"; then
      continue
    fi

    app_count=$((app_count + 1))

    # Check app for updates
    local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"

    if [[ ! -d "${repo_dir}" ]]; then
      log_msg "WARN" "${app_name}: Repository directory not found"
      continue
    fi

    cd "${repo_dir}" || { log_msg "WARN" "${app_name}: Cannot change to repository directory"; continue; }

    # Ensure we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
      log_msg "WARN" "${app_name}: Not a git repository"
      continue
    fi

    # Fetch latest changes (quietly)
    if ! git_with_timeout fetch origin 2>/dev/null; then
      log_msg "ERROR" "${app_name}: Failed to fetch from origin"
      continue
    fi

    # Get current HEAD and remote HEAD
    local local_head
    local remote_head
    local_head=$(git rev-parse HEAD)

    # Get the tracking branch
    local tracking_branch
    tracking_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")

    if [[ -z "${tracking_branch}" ]]; then
      log_msg "WARN" "${app_name}: No tracking branch configured"
      continue
    fi

    remote_head=$(git rev-parse "${tracking_branch}")

    # Check if update is needed
    if [[ "${local_head}" != "${remote_head}" ]]; then
      log_msg "INFO" "${app_name}: Update detected (${local_head:0:8}  ${remote_head:0:8})"

      # Trigger update via cmd_update
      if cmd_update "${app_name}"; then
        log_msg "INFO" "${app_name}: Successfully updated"
        updated_count=$((updated_count + 1))
      else
        log_msg "ERROR" "${app_name}: Update failed"
      fi
    fi
  done

  if [[ ${app_count} -eq 0 ]]; then
    log_msg "INFO" "No apps found"
  elif [[ ${updated_count} -eq 0 ]]; then
    log_msg "INFO" "Checked ${app_count} app(s), no updates available"
  else
    log_msg "INFO" "Checked ${app_count} app(s), updated ${updated_count}"
  fi
}

# -----------------------------------------------------------------------------
# Function: main
# Description: Main CLI dispatcher
# -----------------------------------------------------------------------------
main() {
  if [[ $# -eq 0 ]]; then
    usage
  fi

  local command="$1"
  shift

  case "${command}" in
    add) cmd_add "$@" ;;
    remove|rm) cmd_remove "$@" ;;
    list|ls) cmd_list "$@" ;;
    status) cmd_status "$@" ;;
    start) cmd_start "$@" ;;
    stop) cmd_stop "$@" ;;
    restart) cmd_restart "$@" ;;
    update) cmd_update "$@" ;;
    check) cmd_check "$@" ;;
    autopull) cmd_autopull "$@" ;;
    logs) cmd_logs "$@" ;;
    env) cmd_env "$@" ;;
    exec) cmd_exec "$@" ;;
    backup) cmd_backup "$@" ;;
    restore) cmd_restore "$@" ;;
    backups) cmd_backups "$@" ;;
    -h|--help|help) usage ;;
    *) die "Unknown command: ${command}. Use 'appmo --help' for usage." ;;
  esac
}

main "$@"
