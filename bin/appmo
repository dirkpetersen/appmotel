#!/usr/bin/env bash

# -----------------------------------------------------------------------------
# Script Name: appmo
# Description: CLI tool for managing Appmotel applications
# -----------------------------------------------------------------------------

set -o errexit
set -o nounset
set -o pipefail
IFS=$'\n\t'

# Constants
readonly APPMOTEL_HOME="/home/appmotel"
readonly APPMOTEL_CONFIG_DIR="${APPMOTEL_HOME}/.config/appmotel"
readonly APPMOTEL_ENV_FILE="${APPMOTEL_CONFIG_DIR}/.env"
readonly APPS_CONFIG_DIR="${APPMOTEL_CONFIG_DIR}"
readonly APPS_DATA_DIR="${APPMOTEL_HOME}/.local/share/appmotel"
readonly TRAEFIK_DYNAMIC_DIR="${APPMOTEL_HOME}/.config/traefik/dynamic"
readonly SYSTEMD_USER_DIR="${APPMOTEL_HOME}/.config/systemd/user"
readonly BACKUPS_DIR="${APPMOTEL_HOME}/.local/share/appmotel-backups"
readonly MIN_PORT=10001
readonly MAX_PORT=59999

# Load appmotel configuration
# Note: Temporarily reset IFS for proper .env parsing, then restore
if [[ -f "${APPMOTEL_ENV_FILE}" ]]; then
  _saved_ifs="${IFS}"
  IFS=$' \t\n'
  # shellcheck source=/dev/null
  source "${APPMOTEL_ENV_FILE}"
  IFS="${_saved_ifs}"
  unset _saved_ifs
fi

# Default resource limits (can be overridden in .env)
readonly DEFAULT_MEMORY_LIMIT="512M"
readonly DEFAULT_CPU_QUOTA="100%"

# Rate limiting defaults
readonly DEFAULT_RATE_LIMIT_AVG=100
readonly DEFAULT_RATE_LIMIT_BURST=50

# Ensure XDG_RUNTIME_DIR is set for systemd --user commands
export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"

# -----------------------------------------------------------------------------
# Function: log_msg
# Description: Prints messages with timestamp
# -----------------------------------------------------------------------------
log_msg() {
  local level="$1"
  local msg="$2"
  printf "[%(%Y-%m-%d %H:%M:%S)T] [%s] %s\n" -1 "${level}" "${msg}" >&2
}

# -----------------------------------------------------------------------------
# Function: die
# Description: Prints error message and exits
# -----------------------------------------------------------------------------
die() {
  log_msg "ERROR" "$1"
  exit 1
}

# -----------------------------------------------------------------------------
# Function: format_timestamp
# Description: Converts UTC timestamp to configured timezone for display
# Input: UTC timestamp in ISO 8601 format (e.g., 2025-12-17T19:58:08Z)
# Output: Human-readable timestamp in configured timezone
# -----------------------------------------------------------------------------
format_timestamp() {
  local utc_timestamp="$1"
  local tz="${TZ:-UTC}"

  if [[ -z "${utc_timestamp}" ]]; then
    echo "N/A"
    return
  fi

  # Use date command with TZ environment variable to convert
  # GNU date can parse ISO 8601 format directly
  local formatted
  if formatted=$(TZ="${tz}" date -d "${utc_timestamp}" "+%Y-%m-%d %H:%M:%S %Z" 2>/dev/null); then
    echo "${formatted}"
  else
    # Fallback: return original timestamp if conversion fails
    echo "${utc_timestamp}"
  fi
}

# -----------------------------------------------------------------------------
# Function: usage
# Description: Prints usage information
# -----------------------------------------------------------------------------
usage() {
  cat <<EOF
Usage: appmo <command> [arguments]

Commands:
  add <app-name> <url|user/repo> [branch]  Add and deploy a new app (default: main)
  remove <app-name>                      Remove an app (alias: rm)
  list                                   List all configured apps (alias: ls)
  status [app-name]                      Show app status
  start <app-name>                       Start an app
  stop <app-name>                        Stop an app
  restart <app-name>                     Restart an app
  update <app-name>                      Manually update an app
  check [app-name]                       Check for available updates (no deploy)
  autopull                               Check all apps for updates and deploy
  logs <app-name> [lines]                View app logs
  env <app-name>                         Edit app's .env file in default editor
  exec <app-name> <command>              Run command in app's environment
  backup <app-name>                      Create a backup of an app
  restore <app-name> [backup-id]         Restore an app from backup
  backups <app-name>                     List available backups for an app

Examples:
  appmo add myapp https://github.com/user/repo main
  appmo status myapp
  appmo autopull
  appmo logs myapp 50
  appmo env myapp
  appmo backup myapp
  appmo restore myapp 2024-01-15-120000
EOF
  exit 0
}

# -----------------------------------------------------------------------------
# Function: validate_app_name
# Description: Validates app name format
# -----------------------------------------------------------------------------
validate_app_name() {
  local app_name="$1"

  if [[ -z "${app_name}" ]]; then
    die "App name cannot be empty"
  fi

  if [[ "${app_name}" =~ [[:space:]] ]]; then
    die "App name cannot contain spaces"
  fi

  if [[ ! "${app_name}" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$ ]]; then
    die "App name must be a valid DNS subdomain label (lowercase alphanumeric and hyphens only)"
  fi
}

# -----------------------------------------------------------------------------
# Function: app_exists
# Description: Checks if an app exists (must have metadata.conf to be considered deployed)
# Note: A directory with only .env.backup from a removed app doesn't count
# -----------------------------------------------------------------------------
app_exists() {
  local app_name="$1"
  [[ -f "${APPS_CONFIG_DIR}/${app_name}/metadata.conf" ]]
}

# -----------------------------------------------------------------------------
# Function: require_app_exists
# Description: Ensures app exists or exits
# -----------------------------------------------------------------------------
require_app_exists() {
  local app_name="$1"
  if ! app_exists "${app_name}"; then
    die "App '${app_name}' does not exist"
  fi
}

# -----------------------------------------------------------------------------
# Function: create_backup
# Description: Creates a backup of an app's data and config
# -----------------------------------------------------------------------------
create_backup() {
  local app_name="$1"
  local backup_id
  backup_id=$(date +%Y-%m-%d-%H%M%S)
  local backup_dir="${BACKUPS_DIR}/${app_name}/${backup_id}"

  mkdir -p "${backup_dir}"

  # Backup config
  if [[ -d "${APPS_CONFIG_DIR}/${app_name}" ]]; then
    cp -r "${APPS_CONFIG_DIR}/${app_name}" "${backup_dir}/config"
  fi

  # Backup repo (excluding .venv and node_modules to save space)
  if [[ -d "${APPS_DATA_DIR}/${app_name}/repo" ]]; then
    tar --exclude='.venv' --exclude='node_modules' --exclude='.git' \
      -czf "${backup_dir}/repo.tar.gz" \
      -C "${APPS_DATA_DIR}/${app_name}" repo 2>/dev/null || true
  fi

  # Backup systemd service file
  if [[ -f "${SYSTEMD_USER_DIR}/appmotel-${app_name}.service" ]]; then
    cp "${SYSTEMD_USER_DIR}/appmotel-${app_name}.service" "${backup_dir}/"
  fi

  # Backup Traefik config
  if [[ -f "${TRAEFIK_DYNAMIC_DIR}/${app_name}.yaml" ]]; then
    cp "${TRAEFIK_DYNAMIC_DIR}/${app_name}.yaml" "${backup_dir}/"
  fi

  echo "${backup_id}"
  log_msg "INFO" "Backup created: ${backup_id}"
}

# -----------------------------------------------------------------------------
# Function: restore_backup
# Description: Restores an app from a backup
# -----------------------------------------------------------------------------
restore_backup() {
  local app_name="$1"
  local backup_id="$2"
  local backup_dir="${BACKUPS_DIR}/${app_name}/${backup_id}"

  if [[ ! -d "${backup_dir}" ]]; then
    die "Backup '${backup_id}' not found for app '${app_name}'"
  fi

  log_msg "INFO" "Restoring from backup: ${backup_id}"

  # Stop service if running
  systemctl --user stop "appmotel-${app_name}" 2>/dev/null || true

  # Restore config
  if [[ -d "${backup_dir}/config" ]]; then
    rm -rf "${APPS_CONFIG_DIR}/${app_name}"
    cp -r "${backup_dir}/config" "${APPS_CONFIG_DIR}/${app_name}"
  fi

  # Restore repo
  if [[ -f "${backup_dir}/repo.tar.gz" ]]; then
    rm -rf "${APPS_DATA_DIR}/${app_name}/repo"
    mkdir -p "${APPS_DATA_DIR}/${app_name}"
    tar -xzf "${backup_dir}/repo.tar.gz" -C "${APPS_DATA_DIR}/${app_name}"
  fi

  # Restore systemd service
  if [[ -f "${backup_dir}/appmotel-${app_name}.service" ]]; then
    cp "${backup_dir}/appmotel-${app_name}.service" "${SYSTEMD_USER_DIR}/"
    systemctl --user daemon-reload
  fi

  # Restore Traefik config
  if [[ -f "${backup_dir}/${app_name}.yaml" ]]; then
    cp "${backup_dir}/${app_name}.yaml" "${TRAEFIK_DYNAMIC_DIR}/"
  fi

  # Reinstall dependencies based on app type
  local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"
  if [[ -f "${repo_dir}/go.mod" ]]; then
    setup_go_env "${repo_dir}"
  elif [[ -f "${repo_dir}/requirements.txt" ]]; then
    setup_python_env "${repo_dir}"
  elif [[ -f "${repo_dir}/package.json" ]]; then
    setup_nodejs_env "${repo_dir}"
  fi

  # Start service
  systemctl --user start "appmotel-${app_name}"

  log_msg "INFO" "Restore completed successfully"
}

# -----------------------------------------------------------------------------
# Function: list_backups
# Description: Lists available backups for an app
# -----------------------------------------------------------------------------
list_backups() {
  local app_name="$1"
  local backup_base="${BACKUPS_DIR}/${app_name}"

  if [[ ! -d "${backup_base}" ]]; then
    log_msg "INFO" "No backups found for app '${app_name}'"
    return
  fi

  printf "%-25s %s\n" "BACKUP ID" "SIZE"
  printf "%-25s %s\n" "---------" "----"

  for backup_dir in "${backup_base}"/*; do
    if [[ -d "${backup_dir}" ]]; then
      local backup_id
      backup_id=$(basename "${backup_dir}")
      local size
      size=$(du -sh "${backup_dir}" 2>/dev/null | cut -f1)
      printf "%-25s %s\n" "${backup_id}" "${size}"
    fi
  done
}

# -----------------------------------------------------------------------------
# Function: parse_env_file
# Description: Parses .env file handling quotes and special characters
# Returns: Variable assignments that can be evaluated
# -----------------------------------------------------------------------------
parse_env_file() {
  local env_file="$1"

  if [[ ! -f "${env_file}" ]]; then
    return
  fi

  while IFS= read -r line || [[ -n "${line}" ]]; do
    # Skip empty lines and comments
    [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue

    # Extract key and value
    if [[ "${line}" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      # Remove surrounding quotes if present
      if [[ "${value}" =~ ^\"(.*)\"$ ]] || [[ "${value}" =~ ^\'(.*)\'$ ]]; then
        value="${BASH_REMATCH[1]}"
      fi

      # Output properly quoted assignment
      printf '%s=%q\n' "${key}" "${value}"
    fi
  done < "${env_file}"
}

# -----------------------------------------------------------------------------
# Function: parse_procfile
# Description: Parses Procfile and returns process definitions
# Returns: Lines in format "process_name:command"
# -----------------------------------------------------------------------------
parse_procfile() {
  local procfile="$1"

  if [[ ! -f "${procfile}" ]]; then
    return 1
  fi

  while IFS= read -r line || [[ -n "${line}" ]]; do
    # Skip empty lines and comments
    [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue

    # Parse "process_name: command"
    if [[ "${line}" =~ ^([a-zA-Z][a-zA-Z0-9_-]*)[[:space:]]*:[[:space:]]*(.+)$ ]]; then
      local proc_name="${BASH_REMATCH[1]}"
      local proc_cmd="${BASH_REMATCH[2]}"
      echo "${proc_name}:${proc_cmd}"
    fi
  done < "${procfile}"
}

# -----------------------------------------------------------------------------
# Function: find_free_port
# Description: Finds a random free port
# -----------------------------------------------------------------------------
find_free_port() {
  local port
  local max_attempts=100
  local attempt=0

  while [[ ${attempt} -lt ${max_attempts} ]]; do
    port=$((MIN_PORT + RANDOM % (MAX_PORT - MIN_PORT)))

    if ! ss -tuln | grep -q ":${port} "; then
      echo "${port}"
      return 0
    fi

    attempt=$((attempt + 1))
  done

  die "Could not find free port after ${max_attempts} attempts"
}

# -----------------------------------------------------------------------------
# Function: update_port_in_env
# Description: Updates PORT and FLASK_PORT in .env file
# -----------------------------------------------------------------------------
update_port_in_env() {
  local env_file="$1"
  local new_port="$2"

  if [[ ! -f "${env_file}" ]]; then
    return 1
  fi

  # Update PORT if it exists
  if grep -q "^PORT=" "${env_file}"; then
    sed -i "s/^PORT=.*/PORT=${new_port}/" "${env_file}"
  fi

  # Also update FLASK_PORT if it exists (Flask apps)
  if grep -q "^FLASK_PORT=" "${env_file}"; then
    sed -i "s/^FLASK_PORT=.*/FLASK_PORT=${new_port}/" "${env_file}"
  fi
}

# -----------------------------------------------------------------------------
# Function: get_port_from_env
# Description: Extracts port from app's .env file
# Checks both config dir (preferred) and repo dir for .env
# -----------------------------------------------------------------------------
get_port_from_env() {
  local app_name="$1"
  local config_env="${APPS_CONFIG_DIR}/${app_name}/.env"
  local repo_env="${APPS_DATA_DIR}/${app_name}/repo/.env"

  # Prefer config dir .env, fall back to repo .env
  local env_file=""
  if [[ -f "${config_env}" ]] && [[ ! -L "${config_env}" ]]; then
    env_file="${config_env}"
  elif [[ -f "${repo_env}" ]]; then
    env_file="${repo_env}"
  else
    return 1
  fi

  # Look for PORT variable (priority order: PORT, FLASK_PORT, other *PORT* vars)
  local port

  # 1. Check for PORT=
  port=$(grep -E '^PORT=' "${env_file}" | head -1 | cut -d'=' -f2 | tr -d ' "'"'" || true)
  if [[ -n "${port}" ]] && [[ "${port}" =~ ^[0-9]+$ ]]; then
    echo "${port}"
    return 0
  fi

  # 2. Check for FLASK_PORT= (common in Flask apps)
  port=$(grep -E '^FLASK_PORT=' "${env_file}" | head -1 | cut -d'=' -f2 | tr -d ' "'"'" || true)
  if [[ -n "${port}" ]] && [[ "${port}" =~ ^[0-9]+$ ]]; then
    echo "${port}"
    return 0
  fi

  # 3. Check for any other *PORT* variable (NODE_PORT, SERVER_PORT, etc.)
  port=$(grep -iE '^[A-Z_]*PORT[A-Z_]*=' "${env_file}" | head -1 | cut -d'=' -f2 | tr -d ' "'"'" || true)
  if [[ -n "${port}" ]] && [[ "${port}" =~ ^[0-9]+$ ]]; then
    echo "${port}"
    return 0
  fi

  return 1
}

# -----------------------------------------------------------------------------
# Function: save_app_metadata
# Description: Saves app metadata to config directory
# -----------------------------------------------------------------------------
save_app_metadata() {
  local app_name="$1"
  local github_url="$2"
  local branch="$3"
  local port="$4"
  local services="${5:-}"  # Optional services string (space-separated component names)

  local config_dir="${APPS_CONFIG_DIR}/${app_name}"
  mkdir -p "${config_dir}"

  local metadata_file="${config_dir}/metadata.conf"

  cat > "${metadata_file}" <<EOF
APP_NAME="${app_name}"
GITHUB_URL="${github_url}"
BRANCH="${branch}"
PORT="${port}"
LAST_DEPLOYMENT="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
EOF

  # Add SERVICES field if provided (for multi-component apps)
  if [[ -n "${services}" ]]; then
    echo "SERVICES=\"${services}\"" >> "${metadata_file}"
  fi

  log_msg "INFO" "App metadata saved"
}

# -----------------------------------------------------------------------------
# Function: setup_app_env_file
# Description: Creates physical .env in config dir and symlinks repo/.env to it
# Looks for template: .env.default, env.default, .env.example, env.example
# -----------------------------------------------------------------------------
setup_app_env_file() {
  local app_name="$1"
  local port="$2"

  local config_dir="${APPS_CONFIG_DIR}/${app_name}"
  local config_env="${config_dir}/.env"
  local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"
  local repo_env="${repo_dir}/.env"

  mkdir -p "${config_dir}"

  # If config .env already exists (from backup restore), skip creation
  if [[ -f "${config_env}" ]] && [[ ! -L "${config_env}" ]]; then
    log_msg "INFO" "Using existing .env from config: ${config_env}"
  else
    # Remove any existing symlink in config dir
    rm -f "${config_env}"

    # Look for template files in repo
    local template_file=""
    for tmpl in ".env.default" "env.default" ".env.example" "env.example"; do
      if [[ -f "${repo_dir}/${tmpl}" ]]; then
        template_file="${repo_dir}/${tmpl}"
        break
      fi
    done

    if [[ -n "${template_file}" ]]; then
      # Copy template to config dir
      cp "${template_file}" "${config_env}"
      log_msg "INFO" "Created .env from template: $(basename "${template_file}")"
    elif [[ -f "${repo_env}" ]] && [[ ! -L "${repo_env}" ]]; then
      # If repo has a real .env file, move it to config
      mv "${repo_env}" "${config_env}"
      log_msg "INFO" "Moved existing .env to config directory"
    else
      # Create empty .env with just PORT
      echo "PORT=${port}" > "${config_env}"
      log_msg "INFO" "Created new .env with PORT=${port}"
    fi
  fi

  # Ensure PORT is set in .env and override any low ports (< 10001)
  # Apps should not dictate their own ports - the PaaS assigns them
  if grep -q "^PORT=" "${config_env}" 2>/dev/null; then
    local existing_port
    existing_port=$(grep "^PORT=" "${config_env}" | cut -d'=' -f2 | tr -d ' ')
    if [[ "${existing_port}" =~ ^[0-9]+$ ]] && [[ "${existing_port}" -lt 10001 ]]; then
      log_msg "WARN" "Overriding low port ${existing_port} with assigned port ${port}"
      update_port_in_env "${config_env}" "${port}"
    fi
  else
    echo "PORT=${port}" >> "${config_env}"
  fi

  # Remove any existing .env in repo (file or symlink)
  rm -f "${repo_env}"

  # Create symlink from repo/.env -> config/.env
  ln -s "${config_env}" "${repo_env}"
  log_msg "INFO" "Created symlink: ${repo_env} -> ${config_env}"
}

# -----------------------------------------------------------------------------
# Function: load_app_metadata
# Description: Loads app metadata from config directory
# -----------------------------------------------------------------------------
load_app_metadata() {
  local app_name="$1"
  local metadata_file="${APPS_CONFIG_DIR}/${app_name}/metadata.conf"

  if [[ ! -f "${metadata_file}" ]]; then
    die "App metadata not found"
  fi

  source "${metadata_file}"
}

# -----------------------------------------------------------------------------
# Function: detect_app_type
# Description: Detects application type and returns start command
# Priority: Go (if go.mod exists) > Python > Node.js > Binary
# -----------------------------------------------------------------------------
detect_app_type() {
  local repo_dir="$1"
  local -n cmd_ref=$2

  # Check for start.sh script first (component-specific startup)
  if [[ -f "${repo_dir}/start.sh" ]]; then
    cmd_ref="bash start.sh"
    return 0
  fi

  # Check Go first (highest priority when go.mod exists)
  # Priority: start.sh > Go > Python > Node.js > Binary
  if [[ -f "${repo_dir}/go.mod" ]]; then
    # Go app - binary should be in bin/ after setup_go_env runs
    if [[ -d "${repo_dir}/bin" ]] && [[ $(find "${repo_dir}/bin" -type f -executable | wc -l) -ge 1 ]]; then
      local bin_file
      # Prefer binary matching module name
      local module_name
      module_name=$(grep "^module " "${repo_dir}/go.mod" | awk '{print $2}' | xargs basename)
      if [[ -x "${repo_dir}/bin/${module_name}" ]]; then
        cmd_ref="bin/${module_name}"
      else
        bin_file=$(find "${repo_dir}/bin" -type f -executable | head -1)
        cmd_ref="bin/$(basename "${bin_file}")"
      fi
      return 0
    fi
    # Binary not built yet, will be built by setup_go_env
    local module_name
    module_name=$(grep "^module " "${repo_dir}/go.mod" | awk '{print $2}' | xargs basename)
    cmd_ref="bin/${module_name}"
    return 0
  elif [[ -f "${repo_dir}/requirements.txt" ]]; then
    # Python app - try multiple detection strategies
    local py_file=""

    # 1. Check for app.py (most common)
    if [[ -f "${repo_dir}/app.py" ]]; then
      py_file="app.py"
    # 2. Check for main.py
    elif [[ -f "${repo_dir}/main.py" ]]; then
      py_file="main.py"
    # 3. Check for <repo_name>.py (e.g., bedbot.py for bedbot repo)
    else
      local repo_name
      repo_name=$(basename "${repo_dir}")
      # Handle "repo" directory from our clone structure
      if [[ "${repo_name}" == "repo" ]]; then
        repo_name=$(basename "$(dirname "${repo_dir}")")
      fi
      if [[ -f "${repo_dir}/${repo_name}.py" ]]; then
        py_file="${repo_name}.py"
      # 4. Check for *<repo_name>*.py pattern (e.g., my-bedbot-app.py)
      elif [[ -n "$(find "${repo_dir}" -maxdepth 1 -name "*${repo_name}*.py" -type f 2>/dev/null | head -1)" ]]; then
        py_file=$(basename "$(find "${repo_dir}" -maxdepth 1 -name "*${repo_name}*.py" -type f | head -1)")
      # 5. Check if there's exactly one .py file
      elif [[ $(find "${repo_dir}" -maxdepth 1 -name "*.py" -type f | wc -l) -eq 1 ]]; then
        py_file=$(basename "$(find "${repo_dir}" -maxdepth 1 -name "*.py" -type f | head -1)")
      fi
    fi

    if [[ -n "${py_file}" ]]; then
      cmd_ref="python3 ${py_file}"
      return 0
    elif [[ -d "${repo_dir}/bin" ]] && [[ $(find "${repo_dir}/bin" -type f -executable | wc -l) -eq 1 ]]; then
      local bin_file
      bin_file=$(find "${repo_dir}/bin" -type f -executable | head -1)
      cmd_ref="$(basename "${bin_file}")"
      return 0
    else
      return 1
    fi
  elif [[ -f "${repo_dir}/package.json" ]]; then
    # Node.js app
    cmd_ref="npm start"
    return 0
  elif [[ -d "${repo_dir}/bin" ]] && [[ $(find "${repo_dir}/bin" -type f -executable | wc -l) -eq 1 ]]; then
    # Single executable in bin
    local bin_file
    bin_file=$(find "${repo_dir}/bin" -type f -executable | head -1)
    cmd_ref="bin/$(basename "${bin_file}")"
    return 0
  fi

  return 1
}

# =============================================================================
# Function: detect_components
# Description: Detects multi-component app structure (frontend, backend, etc)
# Returns: Modifies array passed by name reference
# Known components: frontend, backend, api, worker, db, cache
# =============================================================================
detect_components() {
  local repo_dir="$1"
  local -n components_ref=$2  # Output array

  local known_components=("frontend" "backend" "api" "worker" "db" "cache")
  local detected=()

  # Check each known component directory
  for component in "${known_components[@]}"; do
    local component_path="${repo_dir}/${component}"

    # Check if component directory exists and has app markers
    if [[ -d "${component_path}" ]]; then
      if [[ -f "${component_path}/package.json" ]] || \
         [[ -f "${component_path}/requirements.txt" ]] || \
         [[ -f "${component_path}/pyproject.toml" ]] || \
         [[ -f "${component_path}/go.mod" ]]; then
        detected+=("${component}")
      fi
    fi
  done

  # Return detected components
  components_ref=("${detected[@]}")
}

# =============================================================================
# Function: get_all_services
# Description: Returns all services for an app from metadata SERVICES field
# Returns: Modifies array passed by name reference
# Fallback: If SERVICES not set, assumes single app for backward compatibility
# =============================================================================
get_all_services() {
  local app_name="$1"
  local -n services_ref=$2  # Output array

  local metadata_file="${APPS_CONFIG_DIR}/${app_name}/metadata.conf"

  if [[ ! -f "${metadata_file}" ]]; then
    services_ref=()
    return 1
  fi

  # Load SERVICES field from metadata (space-separated component names)
  local services_str
  services_str=$(grep "^SERVICES=" "${metadata_file}" 2>/dev/null | cut -d'=' -f2 | tr -d '"')

  if [[ -n "${services_str}" ]]; then
    # Convert space-separated to array (temporarily use default IFS for splitting)
    local saved_ifs="${IFS}"
    IFS=' '
    read -ra services_ref <<< "${services_str}"
    IFS="${saved_ifs}"
  else
    # Fallback for single-component apps (backward compatibility)
    # Apps without SERVICES field use the app name as single service
    services_ref=("${app_name}")
  fi
}

# =============================================================================
# Function: create_systemd_service
# Description: Creates systemd service for app or app component
# Parameters:
#   $1: app_name
#   $2: repo_dir (or component_dir if component specified)
#   $3: [optional] component_name (e.g., "frontend", "backend")
#   $4: [optional] component_port (internal port for backends, uses PORT from env for frontend)
# Examples:
#   create_systemd_service myapp /path/to/repo                    # Single app
#   create_systemd_service compliance /path/to/compliance/frontend # Frontend component
#   create_systemd_service compliance /path/to/compliance/backend 8001  # Backend component
# =============================================================================
create_systemd_service() {
  local app_name="$1"
  local repo_dir="$2"
  local port="$3"
  local component_name="${4:-}"  # Optional component name (e.g., "frontend", "backend")

  # Service file naming: appmotel-{app_name}[-{component_name}].service
  # Frontend gets no suffix (appmotel-<app>.service), others get suffix
  local service_name="appmotel-${app_name}"
  if [[ -n "${component_name}" ]] && [[ "${component_name}" != "frontend" ]]; then
    service_name="${service_name}-${component_name}"
  fi
  local service_file="${SYSTEMD_USER_DIR}/${service_name}.service"
  local env_file="${repo_dir}/.env"

  # Detect app type and get start command
  local start_cmd=""
  if ! detect_app_type "${repo_dir}" start_cmd; then
    die "Could not determine how to run the app. Please check app structure."
  fi

  log_msg "INFO" "Detected start command: ${start_cmd}"

  # For Python apps, use the venv python directly
  # Only apply if start_cmd actually uses python3 (not for Go/Node apps with requirements.txt)
  if [[ "${start_cmd}" == *"python3"* ]] && [[ -f "${repo_dir}/.venv/bin/python3" ]]; then
    # Replace python3 with full path to venv python
    start_cmd="${start_cmd/python3/${repo_dir}\/.venv\/bin\/python3}"
    log_msg "INFO" "Using virtual environment Python: ${start_cmd}"
  elif [[ -f "${repo_dir}/.venv/bin/python3" ]]; then
    # Python venv exists - PATH will be set in service file
    log_msg "INFO" "Virtual environment detected - PATH will include venv"
  fi

  # Build environment file directive
  local env_directive=""
  if [[ -f "${env_file}" ]]; then
    env_directive="EnvironmentFile=${env_file}"
  fi

  # Get resource limits from .env or use defaults
  local memory_limit="${DEFAULT_MEMORY_LIMIT}"
  local cpu_quota="${DEFAULT_CPU_QUOTA}"

  if [[ -f "${env_file}" ]]; then
    # Parse env file for resource overrides
    local parsed_env
    parsed_env=$(parse_env_file "${env_file}")
    if echo "${parsed_env}" | grep -q "^MEMORY_LIMIT="; then
      memory_limit=$(echo "${parsed_env}" | grep "^MEMORY_LIMIT=" | cut -d= -f2-)
    fi
    if echo "${parsed_env}" | grep -q "^CPU_QUOTA="; then
      cpu_quota=$(echo "${parsed_env}" | grep "^CPU_QUOTA=" | cut -d= -f2-)
    fi
  fi

  # Build description with optional component
  local description="Appmotel Application: ${app_name}"
  if [[ -n "${component_name}" ]]; then
    description="${description} (${component_name})"
  fi

  # For Python apps with venv, add PATH to include venv bin
  local path_directive=""
  if [[ -f "${repo_dir}/.venv/bin/python3" ]]; then
    path_directive="Environment=\"PATH=${repo_dir}/.venv/bin:/usr/local/bin:/usr/bin:/bin\""
  fi

  cat > "${service_file}" <<EOF
[Unit]
Description=${description}
After=network-online.target

[Service]
Type=simple
WorkingDirectory=${repo_dir}
${env_directive}
${path_directive}
Environment="PORT=${port}"
Environment="HOME=${APPMOTEL_HOME}"
Environment="USER=appmotel"
ExecStart=/bin/bash -c '${start_cmd}'
Restart=always
RestartSec=10

# Resource limits
MemoryMax=${memory_limit}
CPUQuota=${cpu_quota}

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=default.target
EOF

  # Ensure XDG_RUNTIME_DIR is set
  export XDG_RUNTIME_DIR="/run/user/$(id -u)"

  systemctl --user daemon-reload
  log_msg "INFO" "Systemd user service created: ${service_name}"
}

# -----------------------------------------------------------------------------
# Function: create_systemd_service_procfile
# Description: Creates systemd service for a Procfile process
# -----------------------------------------------------------------------------
create_systemd_service_procfile() {
  local app_name="$1"
  local proc_name="$2"
  local repo_dir="$3"
  local port="$4"
  local start_cmd="$5"

  local service_file="${SYSTEMD_USER_DIR}/appmotel-${app_name}-${proc_name}.service"
  local env_file="${repo_dir}/.env"

  # For Python apps, use the venv python directly
  # Only apply if start_cmd actually uses python (not for Go/Node apps)
  if [[ "${start_cmd}" == *"python"* ]] && [[ -f "${repo_dir}/.venv/bin/python3" ]]; then
    start_cmd="${start_cmd/python3/${repo_dir}\/.venv\/bin\/python3}"
    start_cmd="${start_cmd/python /${repo_dir}\/.venv\/bin\/python3 }"
  fi

  # Build environment file directive
  local env_directive=""
  if [[ -f "${env_file}" ]]; then
    env_directive="EnvironmentFile=${env_file}"
  fi

  # Get resource limits
  local memory_limit="${DEFAULT_MEMORY_LIMIT}"
  local cpu_quota="${DEFAULT_CPU_QUOTA}"

  if [[ -f "${env_file}" ]]; then
    local parsed_env
    parsed_env=$(parse_env_file "${env_file}")
    if echo "${parsed_env}" | grep -q "^MEMORY_LIMIT="; then
      memory_limit=$(echo "${parsed_env}" | grep "^MEMORY_LIMIT=" | cut -d= -f2-)
    fi
    if echo "${parsed_env}" | grep -q "^CPU_QUOTA="; then
      cpu_quota=$(echo "${parsed_env}" | grep "^CPU_QUOTA=" | cut -d= -f2-)
    fi
  fi

  cat > "${service_file}" <<EOF
[Unit]
Description=Appmotel Application: ${app_name} (${proc_name})
After=network-online.target

[Service]
Type=simple
WorkingDirectory=${repo_dir}
${env_directive}
Environment="PORT=${port}"
Environment="HOME=${APPMOTEL_HOME}"
Environment="USER=appmotel"
ExecStart=/bin/bash -c '${start_cmd}'
Restart=always
RestartSec=10

# Resource limits
MemoryMax=${memory_limit}
CPUQuota=${cpu_quota}

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=default.target
EOF

  systemctl --user daemon-reload
  log_msg "INFO" "Systemd service created: appmotel-${app_name}-${proc_name}"
}

# -----------------------------------------------------------------------------
# Function: create_traefik_config
# Description: Creates Traefik dynamic configuration for app
# -----------------------------------------------------------------------------
create_traefik_config() {
  local app_name="$1"
  local port="$2"
  local base_domain="${3:-apps.example.edu}"
  local repo_dir="${4:-}"

  local config_file="${TRAEFIK_DYNAMIC_DIR}/${app_name}.yaml"
  local app_url="${app_name}.${base_domain}"

  # Get rate limit settings from .env or use defaults
  local rate_limit_avg="${DEFAULT_RATE_LIMIT_AVG}"
  local rate_limit_burst="${DEFAULT_RATE_LIMIT_BURST}"
  local health_check_path=""  # No health check by default - only if app explicitly sets it
  local enable_rate_limit="true"

  if [[ -n "${repo_dir}" ]] && [[ -f "${repo_dir}/.env" ]]; then
    local parsed_env
    parsed_env=$(parse_env_file "${repo_dir}/.env")
    if echo "${parsed_env}" | grep -q "^RATE_LIMIT_AVG="; then
      rate_limit_avg=$(echo "${parsed_env}" | grep "^RATE_LIMIT_AVG=" | cut -d= -f2-)
    fi
    if echo "${parsed_env}" | grep -q "^RATE_LIMIT_BURST="; then
      rate_limit_burst=$(echo "${parsed_env}" | grep "^RATE_LIMIT_BURST=" | cut -d= -f2-)
    fi
    if echo "${parsed_env}" | grep -q "^HEALTH_CHECK_PATH="; then
      health_check_path=$(echo "${parsed_env}" | grep "^HEALTH_CHECK_PATH=" | cut -d= -f2-)
    fi
    if echo "${parsed_env}" | grep -q "^DISABLE_RATE_LIMIT="; then
      enable_rate_limit="false"
    fi
  fi

  # Build middleware list
  local middlewares_line=""
  if [[ "${enable_rate_limit}" == "true" ]]; then
    middlewares_line="middlewares:
        - ${app_name}-ratelimit"
  fi

  # Build health check section (only if explicitly configured)
  local health_check_section=""
  if [[ -n "${health_check_path}" ]]; then
    health_check_section="healthCheck:
          path: ${health_check_path}
          interval: 30s
          timeout: 5s"
  fi

  cat > "${config_file}" <<EOF
http:
  routers:
    ${app_name}:
      rule: "Host(\`${app_url}\`)"
      entryPoints:
        - websecure
      service: ${app_name}
      ${middlewares_line}
      tls: {}

  services:
    ${app_name}:
      loadBalancer:
        servers:
          - url: "http://localhost:${port}"
        ${health_check_section}

  middlewares:
    ${app_name}-ratelimit:
      rateLimit:
        average: ${rate_limit_avg}
        burst: ${rate_limit_burst}
EOF

  log_msg "INFO" "Traefik config created: ${app_url} -> localhost:${port}"
}

# -----------------------------------------------------------------------------
# Function: run_install_script
# Description: Runs app's install.sh script
# -----------------------------------------------------------------------------
run_install_script() {
  local repo_dir="$1"
  local install_script="${repo_dir}/install.sh"

  if [[ ! -f "${install_script}" ]]; then
    log_msg "WARN" "No install.sh found in repository, skipping installation steps"
    return 0
  fi

  if [[ ! -x "${install_script}" ]]; then
    chmod +x "${install_script}"
  fi

  log_msg "INFO" "Running install.sh"

  cd "${repo_dir}"

  if bash "${install_script}"; then
    log_msg "INFO" "Installation completed successfully"
    return 0
  else
    log_msg "ERROR" "Installation script failed"
    return 1
  fi
}

# -----------------------------------------------------------------------------
# Function: setup_python_env
# Description: Sets up Python virtual environment
# -----------------------------------------------------------------------------
setup_python_env() {
  local repo_dir="$1"

  if [[ ! -f "${repo_dir}/requirements.txt" ]]; then
    return 0
  fi

  log_msg "INFO" "Setting up Python virtual environment"

  cd "${repo_dir}"

  if [[ ! -d ".venv" ]]; then
    python3 -m venv .venv
  fi

  source .venv/bin/activate
  pip install --upgrade pip
  pip install -r requirements.txt

  log_msg "INFO" "Python dependencies installed"
}

# -----------------------------------------------------------------------------
# Function: setup_nodejs_env
# Description: Sets up Node.js environment
# -----------------------------------------------------------------------------
setup_nodejs_env() {
  local repo_dir="$1"

  if [[ ! -f "${repo_dir}/package.json" ]]; then
    return 0
  fi

  log_msg "INFO" "Installing Node.js dependencies"

  cd "${repo_dir}"
  npm install

  # Check if this is a Next.js app with static export
  local nextjs_config=""
  if [[ -f "${repo_dir}/next.config.js" ]]; then
    nextjs_config="${repo_dir}/next.config.js"
  elif [[ -f "${repo_dir}/next.config.mjs" ]]; then
    nextjs_config="${repo_dir}/next.config.mjs"
  fi

  if [[ -n "${nextjs_config}" ]]; then
    # Check if output: 'export' is configured
    if grep -q "output.*['\"]export['\"]" "${nextjs_config}" 2>/dev/null; then
      log_msg "INFO" "Detected Next.js static export - building application"

      # Build the static export
      npm run build

      # Install serve for static hosting
      npm install serve

      # Update package.json start script to use serve
      if command -v jq &> /dev/null; then
        # Use jq if available (more robust)
        local tmp_file="/tmp/package_json_$$.tmp"
        jq '.scripts.start = "serve -l ${PORT:-3000} out"' "${repo_dir}/package.json" > "${tmp_file}"
        mv "${tmp_file}" "${repo_dir}/package.json"
      else
        # Fallback to npm pkg set
        npm pkg set scripts.start="serve -l \${PORT:-3000} out"
      fi

      log_msg "INFO" "Next.js static export built successfully"
    fi
  fi

  # Check if this is a Vite app that needs building
  if [[ -f "${repo_dir}/vite.config.ts" ]] || [[ -f "${repo_dir}/vite.config.js" ]]; then
    if grep -q '"build".*vite build' "${repo_dir}/package.json"; then
      log_msg "INFO" "Detected Vite app - building for production"

      # Build the app
      npm run build

      # Install serve for static hosting
      npm install serve

      # Add/update start script that serves the dist folder
      if command -v jq &> /dev/null; then
        local tmp_file="/tmp/package_json_$$.tmp"
        jq '.scripts.start = "serve -l ${PORT:-3000} dist"' "${repo_dir}/package.json" > "${tmp_file}"
        mv "${tmp_file}" "${repo_dir}/package.json"
      else
        npm pkg set scripts.start="serve -l \${PORT:-3000} dist"
      fi

      log_msg "INFO" "Vite app built successfully"
    fi
  fi

  log_msg "INFO" "Node.js dependencies installed"
}

# -----------------------------------------------------------------------------
# Function: setup_go_env
# Description: Sets up Go environment and builds the application
# -----------------------------------------------------------------------------
setup_go_env() {
  local repo_dir="$1"

  if [[ ! -f "${repo_dir}/go.mod" ]]; then
    return 0
  fi

  # Check if go is installed
  if ! command -v go &>/dev/null; then
    die "Go is not installed. Please install Go to deploy Go applications.
    Ubuntu/Debian: sudo apt-get install golang-go
    RHEL/CentOS:   sudo dnf install golang"
  fi

  log_msg "INFO" "Building Go application"

  cd "${repo_dir}"

  # Download dependencies
  log_msg "INFO" "Downloading Go dependencies"
  go mod download

  # Build the application
  # Try to find the module name from go.mod for the binary name
  local module_name
  module_name=$(grep "^module " go.mod | awk '{print $2}' | xargs basename)

  # Build into bin directory
  mkdir -p "${repo_dir}/bin"

  # Check for cmd/ directory structure (common Go project layout)
  if [[ -d "${repo_dir}/cmd" ]]; then
    # Build all commands in cmd/ directory
    local cmd_count=0
    for cmd_dir in "${repo_dir}/cmd"/*; do
      if [[ -d "${cmd_dir}" ]] && [[ -f "${cmd_dir}/main.go" ]]; then
        local cmd_name
        cmd_name=$(basename "${cmd_dir}")
        log_msg "INFO" "Compiling Go binary: ${cmd_name}"
        if go build -o "${repo_dir}/bin/${cmd_name}" "${cmd_dir}"; then
          chmod +x "${repo_dir}/bin/${cmd_name}"
          log_msg "INFO" "Built: bin/${cmd_name}"
          cmd_count=$((cmd_count + 1))
        else
          log_msg "WARN" "Failed to build ${cmd_name}"
        fi
      fi
    done
    if [[ ${cmd_count} -eq 0 ]]; then
      die "No Go commands found in cmd/ directory"
    fi
    log_msg "INFO" "Go application built successfully (${cmd_count} binaries)"
  else
    # Try to build from root directory
    log_msg "INFO" "Compiling Go binary: ${module_name}"
    if go build -o "${repo_dir}/bin/${module_name}" .; then
      chmod +x "${repo_dir}/bin/${module_name}"
      log_msg "INFO" "Go application built successfully: bin/${module_name}"
    else
      die "Failed to build Go application"
    fi
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_add
# Description: Adds a new app
# -----------------------------------------------------------------------------
cmd_add() {
  if [[ $# -lt 2 ]]; then
    die "Usage: appmo add <app-name> <github-url|user/repo> [branch]"
  fi

  local app_name="$1"
  local github_url="$2"
  local branch="${3:-main}"

  # Auto-expand short GitHub URLs (e.g., "user/repo" -> "https://github.com/user/repo")
  if [[ ! "${github_url}" =~ ^(https?://|git@) ]] && [[ "${github_url}" =~ ^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$ ]]; then
    github_url="https://github.com/${github_url}"
    log_msg "INFO" "Expanded to: ${github_url}"
  fi

  validate_app_name "${app_name}"

  if app_exists "${app_name}"; then
    die "App '${app_name}' already exists"
  fi

  log_msg "INFO" "Adding app: ${app_name}"

  # Create directories
  local app_data_dir="${APPS_DATA_DIR}/${app_name}"
  local repo_dir="${app_data_dir}/repo"

  mkdir -p "${app_data_dir}"

  # Clone or update repository
  if [[ -d "${repo_dir}/.git" ]]; then
    # Repo exists, pull latest changes
    log_msg "INFO" "Repository exists, pulling latest: ${github_url}"
    cd "${repo_dir}"
    if ! git fetch origin && git checkout "${branch}" && git pull origin "${branch}"; then
      log_msg "WARN" "Git pull failed, removing and re-cloning"
      rm -rf "${repo_dir}"
      if ! git clone --branch "${branch}" "${github_url}" "${repo_dir}"; then
        rm -rf "${app_data_dir}"
        die "Failed to clone repository"
      fi
    fi
  elif [[ -d "${repo_dir}" ]]; then
    # Directory exists but not a git repo, remove and clone
    log_msg "WARN" "Directory exists but not a git repo, removing"
    rm -rf "${repo_dir}"
    log_msg "INFO" "Cloning repository: ${github_url}"
    if ! git clone --branch "${branch}" "${github_url}" "${repo_dir}"; then
      rm -rf "${app_data_dir}"
      die "Failed to clone repository"
    fi
  else
    # Fresh clone
    log_msg "INFO" "Cloning repository: ${github_url}"
    if ! git clone --branch "${branch}" "${github_url}" "${repo_dir}"; then
      rm -rf "${app_data_dir}"
      die "Failed to clone repository"
    fi
  fi

  # Check for existing .env backup and offer to restore
  local config_dir="${APPS_CONFIG_DIR}/${app_name}"
  local env_backup="${config_dir}/.env.backup"
  if [[ -f "${env_backup}" ]]; then
    printf "Found previous .env backup for '${app_name}'. Restore it? [Y/n] "
    read -r restore_answer
    case "${restore_answer}" in
      [nN]|[nN][oO])
        log_msg "INFO" "Starting with fresh .env"
        rm -f "${env_backup}"
        ;;
      *)
        log_msg "INFO" "Restoring .env from backup"
        mkdir -p "${config_dir}"
        mv "${env_backup}" "${config_dir}/.env"
        ;;
    esac
  fi

  # Determine port (check config .env first, then repo .env, then assign new)
  local port
  local port_from_env=""
  if port_from_env=$(get_port_from_env "${app_name}"); then
    # Check if port is too low (< 10001) - override with high port
    if [[ "${port_from_env}" -lt 10001 ]]; then
      log_msg "WARN" "Port ${port_from_env} from .env is too low, assigning high port"
      port=$(find_free_port)
      log_msg "INFO" "Assigned new port: ${port}"
      # Update the .env file with new port if it exists
      local config_env="${APPS_CONFIG_DIR}/${app_name}/.env"
      if [[ -f "${config_env}" ]]; then
        update_port_in_env "${config_env}" "${port}"
      fi
    # Check if the port from .env is still free
    elif ss -tuln | grep -q ":${port_from_env} "; then
      log_msg "WARN" "Port ${port_from_env} from .env is already in use"
      port=$(find_free_port)
      log_msg "INFO" "Assigned new port: ${port}"
      # Update the .env file with new port if it exists
      local config_env="${APPS_CONFIG_DIR}/${app_name}/.env"
      if [[ -f "${config_env}" ]]; then
        update_port_in_env "${config_env}" "${port}"
      fi
    else
      port="${port_from_env}"
      log_msg "INFO" "Using port from .env: ${port}"
    fi
  else
    port=$(find_free_port)
    log_msg "INFO" "Assigned port: ${port}"
  fi

  # Setup .env file (physical in config dir, symlink in repo)
  setup_app_env_file "${app_name}" "${port}"

  # Detect multi-component structure (frontend, backend, api, etc.)
  local -a detected_components
  detect_components "${repo_dir}" detected_components

  local services_to_deploy=()

  if [[ ${#detected_components[@]} -gt 1 ]]; then
    # Multi-component app detected
    log_msg "INFO" "Detected multi-component app: ${detected_components[*]}"
    services_to_deploy=("${detected_components[@]}")
  else
    # Single-component app - detect type and setup root repo
    local app_type="unknown"
    if [[ -f "${repo_dir}/go.mod" ]]; then
      app_type="go"
    elif [[ -f "${repo_dir}/requirements.txt" ]] || [[ -f "${repo_dir}/pyproject.toml" ]]; then
      app_type="python"
    elif [[ -f "${repo_dir}/package.json" ]]; then
      app_type="nodejs"
    fi

    log_msg "INFO" "Detected app type: ${app_type}"

    case "${app_type}" in
      go)
        setup_go_env "${repo_dir}" || {
          rm -rf "${app_data_dir}"
          die "Failed to build Go application"
        }
        ;;
      python)
        setup_python_env "${repo_dir}" || {
          rm -rf "${app_data_dir}"
          die "Failed to setup Python environment"
        }
        ;;
      nodejs)
        setup_nodejs_env "${repo_dir}" || {
          rm -rf "${app_data_dir}"
          die "Failed to setup Node.js environment"
        }
        ;;
      *)
        log_msg "WARN" "Unknown app type, skipping environment setup"
        ;;
    esac

    # Run install script for single app
    if ! run_install_script "${repo_dir}"; then
      rm -rf "${app_data_dir}"
      die "Installation failed, rolling back"
    fi

    services_to_deploy=()
  fi

  # Use BASE_DOMAIN from .env (sourced at script start) or default
  local base_domain="${BASE_DOMAIN:-apps.example.edu}"

  # Setup all detected services (multi-component or fallback to Procfile/single)
  if [[ ${#services_to_deploy[@]} -gt 0 ]]; then
    # Multi-component deployment
    log_msg "INFO" "Setting up ${#services_to_deploy[@]} components..."

    for component in "${services_to_deploy[@]}"; do
      local component_dir="${repo_dir}/${component}"
      local component_port="${port}"

      # Only frontend gets the public port; others run internal
      if [[ "${component}" != "frontend" ]]; then
        component_port=$(find_free_port)
        log_msg "INFO" "Assigned internal port ${component_port} for ${component}"
      fi

      log_msg "INFO" "Setting up component: ${component}"

      # Detect and setup component type
      if [[ -f "${component_dir}/go.mod" ]]; then
        setup_go_env "${component_dir}" || {
          rm -rf "${app_data_dir}"
          die "Failed to build Go component: ${component}"
        }
      elif [[ -f "${component_dir}/requirements.txt" ]] || [[ -f "${component_dir}/pyproject.toml" ]]; then
        setup_python_env "${component_dir}" || {
          rm -rf "${app_data_dir}"
          die "Failed to setup Python component: ${component}"
        }
      elif [[ -f "${component_dir}/package.json" ]]; then
        setup_nodejs_env "${component_dir}" || {
          rm -rf "${app_data_dir}"
          die "Failed to setup Node.js component: ${component}"
        }
      fi

      # Run install script if exists in component
      if [[ -f "${component_dir}/install.sh" ]]; then
        log_msg "INFO" "Running install script for ${component}"
        cd "${component_dir}"
        if ! bash install.sh; then
          rm -rf "${app_data_dir}"
          die "Installation failed for component: ${component}"
        fi
      fi

      # Create systemd service for component
      # Frontend uses appmotel-<app>.service (no suffix), others get suffix
      local service_suffix=""
      if [[ "${component}" != "frontend" ]]; then
        service_suffix="-${component}"
      fi
      create_systemd_service "${app_name}" "${component_dir}" "${component_port}" "${component}"

      # Enable and start service
      systemctl --user enable "appmotel-${app_name}${service_suffix}"
      systemctl --user start "appmotel-${app_name}${service_suffix}"
    done

    # Create Traefik config only for frontend (public port)
    create_traefik_config "${app_name}" "${port}" "${base_domain}" "${repo_dir}"

    # Save metadata with services list
    services_str=$(echo "${services_to_deploy[@]}" | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
    save_app_metadata "${app_name}" "${github_url}" "${branch}" "${port}" "${services_str}"
  else
    # Single-component deployment - check for Procfile or standard single service
    local procfile="${repo_dir}/Procfile"
    if [[ -f "${procfile}" ]]; then
      log_msg "INFO" "Procfile detected, setting up multi-process app"

      local proc_count=0
      while IFS= read -r proc_line; do
        if [[ "${proc_line}" =~ ^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$ ]]; then
          local proc_name="${BASH_REMATCH[1]}"
          local proc_cmd="${BASH_REMATCH[2]}"
          local proc_port="${port}"

          # Web process gets the main port, others get incremented ports
          if [[ "${proc_name}" != "web" ]]; then
            ((proc_count++))
            proc_port=$((port + proc_count))
          fi

          log_msg "INFO" "Creating service for process: ${proc_name} (port ${proc_port})"
          create_systemd_service_procfile "${app_name}" "${proc_name}" "${repo_dir}" "${proc_port}" "${proc_cmd}"

          # Enable and start service
          systemctl --user enable "appmotel-${app_name}-${proc_name}"
          systemctl --user start "appmotel-${app_name}-${proc_name}"
        fi
      done < <(parse_procfile "${procfile}")

      # Create Traefik config (only routes to web process on main port)
      create_traefik_config "${app_name}" "${port}" "${base_domain}" "${repo_dir}"
    else
      # Single process app
      create_systemd_service "${app_name}" "${repo_dir}" "${port}"

      # Create Traefik config with repo_dir for settings
      create_traefik_config "${app_name}" "${port}" "${base_domain}" "${repo_dir}"

      # Start service
      systemctl --user enable "appmotel-${app_name}"
      systemctl --user start "appmotel-${app_name}"
    fi

    # Save metadata (no SERVICES field for single-component)
    save_app_metadata "${app_name}" "${github_url}" "${branch}" "${port}"
  fi

  local app_url="https://${app_name}.${base_domain}"

  log_msg "INFO" "App '${app_name}' added successfully"
  log_msg "INFO" "URL: ${app_url}"
  log_msg "INFO" "Status: appmo status ${app_name}"
  log_msg "INFO" "Logs: appmo logs ${app_name}"
  log_msg "INFO" ""

  # Check if BASE_DOMAIN is still set to default
  if [[ "${base_domain}" == "apps.example.edu" ]] || [[ "${base_domain}" == "apps.yourdomain.edu" ]]; then
    log_msg "WARN" "  BASE_DOMAIN is set to default value: ${base_domain}"
    log_msg "WARN" "   Please update BASE_DOMAIN in ~/.config/appmotel/.env"
    log_msg "WARN" "   Then restart Traefik: sudo systemctl restart traefik-appmotel"
    return
  fi

  # Check if the app URL is reachable (retry for 15 seconds)
  log_msg "INFO" "Checking if app is accessible..."

  local http_code
  local response_body
  local max_attempts=15
  local attempt=1
  local app_accessible=false

  while [[ ${attempt} -le ${max_attempts} ]]; do
    http_code=$(curl -s -o /tmp/appmo_check_$$.html -w '%{http_code}' --connect-timeout 2 --max-time 3 -k "${app_url}" 2>/dev/null || echo "000")
    response_body=$(cat /tmp/appmo_check_$$.html 2>/dev/null || echo "")
    rm -f /tmp/appmo_check_$$.html

    # Check for successful HTTP status (2xx or 3xx) and no "Bad Gateway" in response
    if [[ "${http_code}" =~ ^[23] ]] && ! grep -qi "bad gateway" <<< "${response_body}"; then
      app_accessible=true
      break
    fi

    # Only wait and retry if not the last attempt
    if [[ ${attempt} -lt ${max_attempts} ]]; then
      sleep 1
    fi
    ((attempt++))
  done

  if [[ "${app_accessible}" == "true" ]]; then
    log_msg "INFO" " App is accessible at ${app_url}"
  else
    if [[ "${http_code}" == "502" ]] || grep -qi "bad gateway" <<< "${response_body}"; then
      log_msg "WARN" "App not accessible - received Bad Gateway error (app may not be running on port ${port})"
    else
      log_msg "WARN" "App not yet accessible - DNS may need configuration"
    fi
    log_msg "INFO" ""
    log_msg "INFO" "DNS Configuration Required:"
    log_msg "INFO" ""
    log_msg "INFO" "   Configure DNS to route traffic to this app. Choose one option:"
    log_msg "INFO" ""
    log_msg "INFO" "   Option 1 (Recommended): Wildcard A record"
    log_msg "INFO" "     *.${base_domain} IN A $(curl -s --connect-timeout 3 ifconfig.me 2>/dev/null || echo 'YOUR_SERVER_IP')"
    log_msg "INFO" "      All subdomains automatically route to this server"
    log_msg "INFO" ""
    log_msg "INFO" "   Option 2: Individual A record"
    log_msg "INFO" "     ${app_name}.${base_domain} IN A $(curl -s --connect-timeout 3 ifconfig.me 2>/dev/null || echo 'YOUR_SERVER_IP')"
    log_msg "INFO" "      Requires manual DNS update for each new app"
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_remove
# Description: Removes an app (also aliased as 'rm')
# Backs up .env file before removal for potential restore on re-add
# -----------------------------------------------------------------------------
cmd_remove() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo remove <app-name>"
  fi

  local app_name="$1"

  require_app_exists "${app_name}"

  log_msg "INFO" "Removing app: ${app_name}"

  # Backup .env file before removal
  local config_dir="${APPS_CONFIG_DIR}/${app_name}"
  local env_file="${config_dir}/.env"
  local env_backup="${config_dir}/.env.backup"

  if [[ -f "${env_file}" ]] && [[ ! -L "${env_file}" ]]; then
    # Create config dir if needed (for storing backup)
    mkdir -p "${config_dir}"
    cp "${env_file}" "${env_backup}"
    log_msg "INFO" "Backed up .env to ${env_backup}"
  fi

  # Get all services for this app (handles multi-component and Procfile)
  local -a services
  get_all_services "${app_name}" services

  # Stop, disable, and remove all service files
  for service in "${services[@]}"; do
    local service_name
    # Frontend gets no suffix, others get suffix
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi

    # Stop and disable service
    if systemctl --user is-active --quiet "${service_name}" 2>/dev/null; then
      systemctl --user stop "${service_name}" 2>/dev/null || true
    fi
    systemctl --user disable "${service_name}" 2>/dev/null || true

    # Remove service file
    rm -f "${SYSTEMD_USER_DIR}/${service_name}.service"
  done
  systemctl --user daemon-reload

  # Remove Traefik config
  rm -f "${TRAEFIK_DYNAMIC_DIR}/${app_name}.yaml"

  # Remove app data
  rm -rf "${APPS_DATA_DIR}/${app_name}"

  # Remove app config (but preserve .env.backup)
  # Move .env.backup to temp, remove dir, recreate with just backup
  if [[ -f "${env_backup}" ]]; then
    local temp_backup
    temp_backup=$(mktemp)
    cp "${env_backup}" "${temp_backup}"
    rm -rf "${config_dir}"
    mkdir -p "${config_dir}"
    mv "${temp_backup}" "${env_backup}"
    log_msg "INFO" ".env backup preserved at ${env_backup}"
    log_msg "INFO" "Re-add app with same name to restore .env"
  else
    rm -rf "${config_dir}"
  fi

  log_msg "INFO" "App '${app_name}' removed successfully"
}

# -----------------------------------------------------------------------------
# Function: cmd_list
# Description: Lists all apps
# -----------------------------------------------------------------------------
cmd_list() {
  if [[ ! -d "${APPS_CONFIG_DIR}" ]]; then
    echo "No apps configured"
    return
  fi

  local -a apps
  mapfile -t apps < <(find "${APPS_CONFIG_DIR}" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort)

  if [[ ${#apps[@]} -eq 0 ]]; then
    echo "No apps configured"
    return
  fi

  printf "%-15s %-10s %-30s %s\n" "APP NAME" "STATUS" "REPO" "URL"
  printf "%-15s %-10s %-30s %s\n" "--------" "------" "----" "---"

  local base_domain="${BASE_DOMAIN:-apps.example.edu}"

  local found_apps=0
  for app in "${apps[@]}"; do
    # Skip directories that only have .env.backup (removed apps)
    if ! app_exists "${app}"; then
      continue
    fi
    found_apps=$((found_apps + 1))

    local status="stopped"
    if systemctl --user is-active --quiet "appmotel-${app}"; then
      status="running"
    fi

    local url="https://${app}.${base_domain}"

    # Get repo from metadata (extract user/repo from GitHub URL)
    local repo=""
    local metadata_file="${APPS_CONFIG_DIR}/${app}/metadata.conf"
    if [[ -f "${metadata_file}" ]]; then
      local github_url
      github_url=$(grep "^GITHUB_URL=" "${metadata_file}" | cut -d'"' -f2)
      # Extract user/repo from URL (handles https://github.com/user/repo or git@github.com:user/repo)
      repo=$(echo "${github_url}" | sed -E 's|^https?://github\.com/||; s|^git@github\.com:||; s|\.git$||')
    fi

    printf "%-15s %-10s %-30s %s\n" "${app}" "${status}" "${repo}" "${url}"
  done

  if [[ ${found_apps} -eq 0 ]]; then
    echo "No apps configured"
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_status
# Description: Shows app status
# -----------------------------------------------------------------------------
cmd_status() {
  local base_domain="${BASE_DOMAIN:-apps.example.edu}"

  if [[ $# -eq 0 ]]; then
    # Show status for all apps
    cmd_list
    return
  fi

  local app_name="$1"

  require_app_exists "${app_name}"

  load_app_metadata "${app_name}"

  # Get all services for this app
  local -a services
  get_all_services "${app_name}" services

  # Show systemctl status for each service (allow failure for stopped services)
  for service in "${services[@]}"; do
    local service_name
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    systemctl --user status "${service_name}" --no-pager 2>/dev/null || true
    echo ""
  done

  echo "App: ${app_name}"
  echo "URL: https://${app_name}.${base_domain}"
  echo "GitHub: ${GITHUB_URL} (${BRANCH})"
  echo "Port: ${PORT}"
  echo "Last Deployment: $(format_timestamp "${LAST_DEPLOYMENT}")"
  echo ""

  # Check status for each service/component
  echo "Service Status:"
  for service in "${services[@]}"; do
    local service_name
    local display_name="${service}"
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
      if [[ "${service}" == "${app_name}" ]]; then
        display_name="main"
      fi
    else
      service_name="appmotel-${app_name}-${service}"
    fi

    echo "  ${display_name}:"
    if systemctl --user is-active --quiet "${service_name}" 2>/dev/null; then
      echo "    Systemd: running"
    else
      echo "    Systemd: stopped"
    fi

    # Check port response for frontend only
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      if timeout 2 bash -c "cat < /dev/null > /dev/tcp/localhost/${PORT}" 2>/dev/null; then
        echo "    Port ${PORT}: responding"
      else
        echo "    Port ${PORT}: not responding"
      fi
    fi
  done
}

# -----------------------------------------------------------------------------
# Function: cmd_start
# Description: Starts an app
# -----------------------------------------------------------------------------
cmd_start() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo start <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  # Get all services for this app (handles multi-component)
  local -a services
  get_all_services "${app_name}" services

  log_msg "INFO" "Starting app: ${app_name}"
  for service in "${services[@]}"; do
    local service_name
    # Frontend gets no suffix, others get suffix
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    systemctl --user start "${service_name}"
  done
  log_msg "INFO" "App started"
}

# -----------------------------------------------------------------------------
# Function: cmd_stop
# Description: Stops an app
# -----------------------------------------------------------------------------
cmd_stop() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo stop <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  # Get all services for this app (handles multi-component)
  local -a services
  get_all_services "${app_name}" services

  log_msg "INFO" "Stopping app: ${app_name}"
  for service in "${services[@]}"; do
    local service_name
    # Frontend gets no suffix, others get suffix
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    systemctl --user stop "${service_name}"
  done
  log_msg "INFO" "App stopped"
}

# -----------------------------------------------------------------------------
# Function: cmd_restart
# Description: Restarts an app
# -----------------------------------------------------------------------------
cmd_restart() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo restart <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  # Get all services for this app (handles multi-component)
  local -a services
  get_all_services "${app_name}" services

  log_msg "INFO" "Restarting app: ${app_name}"
  for service in "${services[@]}"; do
    local service_name
    # Frontend gets no suffix, others get suffix
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    systemctl --user restart "${service_name}"
  done
  log_msg "INFO" "App restarted"
}

# -----------------------------------------------------------------------------
# Function: cmd_update
# Description: Updates an app with automatic backup and rollback on failure
# -----------------------------------------------------------------------------
cmd_update() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo update <app-name>"
  fi

  local app_name="$1"

  require_app_exists "${app_name}"

  load_app_metadata "${app_name}"

  local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"

  log_msg "INFO" "Updating app: ${app_name}"

  # Create backup before update
  log_msg "INFO" "Creating backup before update..."
  local backup_id
  backup_id=$(create_backup "${app_name}")

  # Track if we need to rollback
  local update_failed=false

  # Pull latest changes
  cd "${repo_dir}"
  if ! git pull origin "${BRANCH}"; then
    log_msg "ERROR" "Failed to pull latest changes"
    update_failed=true
  fi

  if [[ "${update_failed}" == "false" ]]; then
    # Check if .env.default has a low port and override it
    # Apps should not dictate their own ports - the PaaS assigns them
    local config_env="${APPS_CONFIG_DIR}/${app_name}/.env"
    local env_default="${repo_dir}/.env.default"

    if [[ -f "${env_default}" ]] && grep -q "^PORT=" "${env_default}" 2>/dev/null; then
      local default_port
      default_port=$(grep "^PORT=" "${env_default}" | cut -d'=' -f2 | tr -d ' ')
      if [[ "${default_port}" =~ ^[0-9]+$ ]] && [[ "${default_port}" -lt 10001 ]]; then
        # Get current port from config .env or assign new one
        local assigned_port="${PORT}"
        if [[ -z "${assigned_port}" ]] || [[ "${assigned_port}" -lt 10001 ]]; then
          assigned_port=$(find_free_port)
        fi
        log_msg "WARN" "App's .env.default has low port ${default_port}, overriding with ${assigned_port}"
        update_port_in_env "${config_env}" "${assigned_port}"
        PORT="${assigned_port}"

        # Update Traefik config with new port
        local base_domain="${BASE_DOMAIN:-apps.example.com}"
        create_traefik_config "${app_name}" "${assigned_port}" "${base_domain}" "${repo_dir}"
      fi
    fi

    # Get all services for this app
    local -a services
    get_all_services "${app_name}" services

    # Check if multi-component app
    if [[ ${#services[@]} -gt 1 ]] && [[ "${services[0]}" != "${app_name}" ]]; then
      # Multi-component: setup each component
      log_msg "INFO" "Updating ${#services[@]} components..."
      for component in "${services[@]}"; do
        local component_dir="${repo_dir}/${component}"
        log_msg "INFO" "Updating component: ${component}"

        # Setup component environment
        if [[ -f "${component_dir}/go.mod" ]]; then
          setup_go_env "${component_dir}" || update_failed=true
        elif [[ -f "${component_dir}/requirements.txt" ]] || [[ -f "${component_dir}/pyproject.toml" ]]; then
          setup_python_env "${component_dir}" || update_failed=true
        elif [[ -f "${component_dir}/package.json" ]]; then
          setup_nodejs_env "${component_dir}" || update_failed=true
        fi

        # Run component install script
        if [[ -f "${component_dir}/install.sh" ]]; then
          cd "${component_dir}"
          if ! bash install.sh; then
            log_msg "ERROR" "Install script failed for ${component}"
            update_failed=true
          fi
        fi
      done
    else
      # Single-component: setup root repo
      setup_python_env "${repo_dir}"
      setup_nodejs_env "${repo_dir}"
      setup_go_env "${repo_dir}"

      # Run install script
      if ! run_install_script "${repo_dir}"; then
        log_msg "ERROR" "Install script failed"
        update_failed=true
      fi
    fi
  fi

  if [[ "${update_failed}" == "true" ]]; then
    log_msg "WARN" "Update failed, rolling back to backup ${backup_id}..."
    restore_backup "${app_name}" "${backup_id}"
    log_msg "INFO" "Rollback completed. App restored to previous version."
    return 1
  fi

  # Get SERVICES string if multi-component
  local services_str=""
  if [[ ${#services[@]} -gt 1 ]] && [[ "${services[0]}" != "${app_name}" ]]; then
    services_str=$(echo "${services[@]}" | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
  fi

  # Update metadata timestamp
  save_app_metadata "${app_name}" "${GITHUB_URL}" "${BRANCH}" "${PORT}" "${services_str}"

  # Restart all services
  log_msg "INFO" "Restarting services..."
  for service in "${services[@]}"; do
    local service_name
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    systemctl --user restart "${service_name}"
  done

  log_msg "INFO" "App updated successfully (backup: ${backup_id})"
}

# -----------------------------------------------------------------------------
# Function: cmd_logs
# Description: Shows app logs
# -----------------------------------------------------------------------------
cmd_logs() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo logs <app-name> [lines]"
  fi

  local app_name="$1"
  local lines="${2:-50}"

  require_app_exists "${app_name}"

  # Get all services for this app
  local -a services
  get_all_services "${app_name}" services

  # Build journalctl command with all service units
  local -a unit_args=()
  for service in "${services[@]}"; do
    local service_name
    if [[ "${service}" == "frontend" ]] || [[ "${service}" == "${app_name}" ]]; then
      service_name="appmotel-${app_name}"
    else
      service_name="appmotel-${app_name}-${service}"
    fi
    unit_args+=("-u" "${service_name}")
  done

  # Show logs from all services
  journalctl --user "${unit_args[@]}" -n "${lines}" --no-pager
}

# -----------------------------------------------------------------------------
# Function: cmd_exec
# Description: Executes command in app environment
# -----------------------------------------------------------------------------
cmd_exec() {
  if [[ $# -lt 2 ]]; then
    die "Usage: appmo exec <app-name> <command>"
  fi

  local app_name="$1"
  shift

  require_app_exists "${app_name}"

  local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"
  local env_file="${repo_dir}/.env"

  cd "${repo_dir}"

  if [[ -f "${env_file}" ]]; then
    set -o allexport
    source "${env_file}"
    set +o allexport
  fi

  # Activate Python venv if it exists
  if [[ -d "${repo_dir}/.venv" ]]; then
    source "${repo_dir}/.venv/bin/activate"
  fi

  "$@"
}

# -----------------------------------------------------------------------------
# Function: cmd_env
# Description: Opens the app's .env file in the default editor
# The physical .env lives in config dir, repo has symlink to it
# -----------------------------------------------------------------------------
cmd_env() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo env <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  # Physical .env is in config directory
  local env_file="${APPS_CONFIG_DIR}/${app_name}/.env"
  local repo_env="${APPS_DATA_DIR}/${app_name}/repo/.env"

  if [[ ! -f "${env_file}" ]]; then
    # Create .env file if it doesn't exist
    mkdir -p "${APPS_CONFIG_DIR}/${app_name}"
    touch "${env_file}"
    log_msg "INFO" "Created new .env file: ${env_file}"
  fi

  # Ensure symlink exists in repo
  if [[ ! -L "${repo_env}" ]]; then
    rm -f "${repo_env}"
    ln -s "${env_file}" "${repo_env}"
  fi

  # Capture file hash before editing to detect changes
  local hash_before=""
  if [[ -f "${env_file}" ]]; then
    hash_before=$(md5sum "${env_file}" 2>/dev/null | awk '{print $1}')
  fi

  # Use EDITOR or VISUAL, fall back to vi
  local editor="${EDITOR:-${VISUAL:-vi}}"

  log_msg "INFO" "Opening ${env_file} with ${editor}"
  "${editor}" "${env_file}"

  # Check if file was modified
  local hash_after=""
  if [[ -f "${env_file}" ]]; then
    hash_after=$(md5sum "${env_file}" 2>/dev/null | awk '{print $1}')
  fi

  if [[ "${hash_before}" != "${hash_after}" ]]; then
    log_msg "INFO" "Environment file changed"
    # Ask user if they want to restart
    printf "Restart app to apply changes? [Y/n] "
    read -r answer
    case "${answer}" in
      [nN]|[nN][oO])
        log_msg "INFO" "Skipping restart. Run 'appmo restart ${app_name}' to apply changes later."
        ;;
      *)
        cmd_restart "${app_name}"
        ;;
    esac
  else
    log_msg "INFO" "No changes detected"
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_backup
# Description: Creates a backup of an app
# -----------------------------------------------------------------------------
cmd_backup() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo backup <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  log_msg "INFO" "Creating backup for app: ${app_name}"
  local backup_id
  backup_id=$(create_backup "${app_name}")
  log_msg "INFO" "Backup created successfully: ${backup_id}"
}

# -----------------------------------------------------------------------------
# Function: cmd_restore
# Description: Restores an app from a backup
# -----------------------------------------------------------------------------
cmd_restore() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo restore <app-name> [backup-id]"
  fi

  local app_name="$1"
  local backup_id="${2:-}"

  require_app_exists "${app_name}"

  # If no backup-id provided, use the most recent
  if [[ -z "${backup_id}" ]]; then
    local backup_base="${BACKUPS_DIR}/${app_name}"
    if [[ ! -d "${backup_base}" ]]; then
      die "No backups found for app '${app_name}'"
    fi
    backup_id=$(ls -t "${backup_base}" | head -1)
    if [[ -z "${backup_id}" ]]; then
      die "No backups found for app '${app_name}'"
    fi
    log_msg "INFO" "Using most recent backup: ${backup_id}"
  fi

  restore_backup "${app_name}" "${backup_id}"
}

# -----------------------------------------------------------------------------
# Function: cmd_backups
# Description: Lists available backups for an app
# -----------------------------------------------------------------------------
cmd_backups() {
  if [[ $# -lt 1 ]]; then
    die "Usage: appmo backups <app-name>"
  fi

  local app_name="$1"
  require_app_exists "${app_name}"

  list_backups "${app_name}"
}

# -----------------------------------------------------------------------------
# Function: cmd_check
# Description: Check for available updates without deploying
# -----------------------------------------------------------------------------
cmd_check() {
  local filter_app="${1:-}"

  # Check if apps directory exists
  if [[ ! -d "${APPS_CONFIG_DIR}" ]]; then
    echo "No apps configured yet"
    return 0
  fi

  # If specific app requested, verify it exists
  if [[ -n "${filter_app}" ]]; then
    require_app_exists "${filter_app}"
  fi

  local updates_available=0
  local app_count=0

  printf "%-15s %-12s %-10s %s\n" "APP" "STATUS" "LOCAL" "REMOTE"
  printf "%-15s %-12s %-10s %s\n" "---" "------" "-----" "------"

  for app_dir in "${APPS_CONFIG_DIR}"/*; do
    if [[ ! -d "${app_dir}" ]]; then
      continue
    fi

    local app_name
    app_name=$(basename "${app_dir}")

    # If filter specified, skip non-matching apps
    if [[ -n "${filter_app}" ]] && [[ "${app_name}" != "${filter_app}" ]]; then
      continue
    fi

    # Skip directories that only have .env.backup (removed apps)
    if ! app_exists "${app_name}"; then
      continue
    fi

    app_count=$((app_count + 1))

    local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"

    if [[ ! -d "${repo_dir}" ]]; then
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "NO REPO" "-" "-"
      continue
    fi

    cd "${repo_dir}"

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "NOT GIT" "-" "-"
      continue
    fi

    # Fetch latest changes (quietly)
    if ! git fetch origin 2>/dev/null; then
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "FETCH ERR" "-" "-"
      continue
    fi

    local local_head
    local remote_head
    local_head=$(git rev-parse HEAD)

    local tracking_branch
    tracking_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")

    if [[ -z "${tracking_branch}" ]]; then
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "NO TRACK" "${local_head:0:8}" "-"
      continue
    fi

    remote_head=$(git rev-parse "${tracking_branch}")

    if [[ "${local_head}" != "${remote_head}" ]]; then
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "UPDATE" "${local_head:0:8}" "${remote_head:0:8}"
      updates_available=$((updates_available + 1))
    else
      printf "%-15s %-12s %-10s %s\n" "${app_name}" "up-to-date" "${local_head:0:8}" "-"
    fi
  done

  echo ""
  if [[ ${app_count} -eq 0 ]]; then
    echo "No apps found"
  elif [[ ${updates_available} -eq 0 ]]; then
    echo "All ${app_count} app(s) are up to date"
  else
    echo "${updates_available} of ${app_count} app(s) have updates available"
    echo "Run 'appmo update <app>' or 'appmo autopull' to deploy"
  fi
}

# -----------------------------------------------------------------------------
# Function: cmd_autopull
# Description: Automatically checks all apps for updates and deploys them
# This is designed to run periodically via systemd timer
# -----------------------------------------------------------------------------
cmd_autopull() {
  local lockfile="${APPS_DATA_DIR}/.autopull.lock"

  # Acquire lock to prevent concurrent runs
  local lockdir
  lockdir=$(dirname "${lockfile}")
  mkdir -p "${lockdir}"

  if [[ -f "${lockfile}" ]]; then
    local pid
    pid=$(cat "${lockfile}")

    # Check if process is still running
    if kill -0 "${pid}" 2>/dev/null; then
      log_msg "INFO" "Another autopull instance is running (PID: ${pid}), exiting"
      exit 0
    else
      log_msg "WARN" "Removing stale lock file"
      rm -f "${lockfile}"
    fi
  fi

  echo $$ > "${lockfile}"
  trap "rm -f ${lockfile}" EXIT

  log_msg "INFO" "Starting autopull check"

  # Check if apps directory exists
  if [[ ! -d "${APPS_CONFIG_DIR}" ]]; then
    log_msg "INFO" "No apps configured yet"
    exit 0
  fi

  # Get list of all apps
  local app_count=0
  local updated_count=0

  for app_dir in "${APPS_CONFIG_DIR}"/*; do
    if [[ ! -d "${app_dir}" ]]; then
      continue
    fi

    local app_name
    app_name=$(basename "${app_dir}")

    # Skip directories that only have .env.backup (removed apps)
    if ! app_exists "${app_name}"; then
      continue
    fi

    app_count=$((app_count + 1))

    # Check app for updates
    local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"

    if [[ ! -d "${repo_dir}" ]]; then
      log_msg "WARN" "${app_name}: Repository directory not found"
      continue
    fi

    cd "${repo_dir}"

    # Ensure we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
      log_msg "WARN" "${app_name}: Not a git repository"
      continue
    fi

    # Fetch latest changes (quietly)
    if ! git fetch origin 2>/dev/null; then
      log_msg "ERROR" "${app_name}: Failed to fetch from origin"
      continue
    fi

    # Get current HEAD and remote HEAD
    local local_head
    local remote_head
    local_head=$(git rev-parse HEAD)

    # Get the tracking branch
    local tracking_branch
    tracking_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")

    if [[ -z "${tracking_branch}" ]]; then
      log_msg "WARN" "${app_name}: No tracking branch configured"
      continue
    fi

    remote_head=$(git rev-parse "${tracking_branch}")

    # Check if update is needed
    if [[ "${local_head}" != "${remote_head}" ]]; then
      log_msg "INFO" "${app_name}: Update detected (${local_head:0:8}  ${remote_head:0:8})"

      # Trigger update via cmd_update
      if cmd_update "${app_name}"; then
        log_msg "INFO" "${app_name}: Successfully updated"
        updated_count=$((updated_count + 1))
      else
        log_msg "ERROR" "${app_name}: Update failed"
      fi
    fi
  done

  if [[ ${app_count} -eq 0 ]]; then
    log_msg "INFO" "No apps found"
  elif [[ ${updated_count} -eq 0 ]]; then
    log_msg "INFO" "Checked ${app_count} app(s), no updates available"
  else
    log_msg "INFO" "Checked ${app_count} app(s), updated ${updated_count}"
  fi
}

# -----------------------------------------------------------------------------
# Function: main
# Description: Main CLI dispatcher
# -----------------------------------------------------------------------------
main() {
  if [[ $# -eq 0 ]]; then
    usage
  fi

  local command="$1"
  shift

  case "${command}" in
    add) cmd_add "$@" ;;
    remove|rm) cmd_remove "$@" ;;
    list|ls) cmd_list "$@" ;;
    status) cmd_status "$@" ;;
    start) cmd_start "$@" ;;
    stop) cmd_stop "$@" ;;
    restart) cmd_restart "$@" ;;
    update) cmd_update "$@" ;;
    check) cmd_check "$@" ;;
    autopull) cmd_autopull "$@" ;;
    logs) cmd_logs "$@" ;;
    env) cmd_env "$@" ;;
    exec) cmd_exec "$@" ;;
    backup) cmd_backup "$@" ;;
    restore) cmd_restore "$@" ;;
    backups) cmd_backups "$@" ;;
    -h|--help|help) usage ;;
    *) die "Unknown command: ${command}. Use 'appmo --help' for usage." ;;
  esac
}

main "$@"
