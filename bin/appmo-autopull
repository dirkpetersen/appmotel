#!/usr/bin/env bash

# -----------------------------------------------------------------------------
# Script Name: appmo-autopull
# Description: Automatically checks all apps for git updates and deploys them
# Designed to run periodically via systemd timer
# -----------------------------------------------------------------------------

set -o errexit
set -o nounset
set -o pipefail
IFS=$'\n\t'

# Constants
readonly APPS_CONFIG_DIR="${HOME}/.config/appmotel/apps"
readonly APPS_DATA_DIR="${HOME}/.local/share/appmotel"
readonly APPMO_CLI="${HOME}/.local/bin/appmo"
readonly LOCKFILE="${HOME}/.local/share/appmotel/.autopull.lock"

# -----------------------------------------------------------------------------
# Function: log_msg
# Description: Prints messages with timestamp
# -----------------------------------------------------------------------------
log_msg() {
  local level="$1"
  local msg="$2"
  printf "[%(%Y-%m-%d %H:%M:%S)T] [AUTOPULL] [%s] %s\n" -1 "${level}" "${msg}"
}

# -----------------------------------------------------------------------------
# Function: acquire_lock
# Description: Ensures only one autopull runs at a time
# -----------------------------------------------------------------------------
acquire_lock() {
  local lockdir
  lockdir=$(dirname "${LOCKFILE}")
  mkdir -p "${lockdir}"

  if [[ -f "${LOCKFILE}" ]]; then
    local pid
    pid=$(cat "${LOCKFILE}")

    # Check if process is still running
    if kill -0 "${pid}" 2>/dev/null; then
      log_msg "INFO" "Another autopull instance is running (PID: ${pid}), exiting"
      exit 0
    else
      log_msg "WARN" "Removing stale lock file"
      rm -f "${LOCKFILE}"
    fi
  fi

  echo $$ > "${LOCKFILE}"
}

# -----------------------------------------------------------------------------
# Function: release_lock
# Description: Removes the lock file
# -----------------------------------------------------------------------------
release_lock() {
  rm -f "${LOCKFILE}"
}

# -----------------------------------------------------------------------------
# Function: check_app_for_updates
# Description: Checks if an app has updates and triggers deployment
# -----------------------------------------------------------------------------
check_app_for_updates() {
  local app_name="$1"
  local repo_dir="${APPS_DATA_DIR}/${app_name}/repo"

  if [[ ! -d "${repo_dir}" ]]; then
    log_msg "WARN" "Repository directory not found for ${app_name}"
    return 1
  fi

  cd "${repo_dir}"

  # Ensure we're in a git repository
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    log_msg "WARN" "${app_name}: Not a git repository"
    return 1
  fi

  # Fetch latest changes (quietly)
  if ! git fetch origin 2>/dev/null; then
    log_msg "ERROR" "${app_name}: Failed to fetch from origin"
    return 1
  fi

  # Get current HEAD and remote HEAD
  local local_head
  local remote_head
  local_head=$(git rev-parse HEAD)

  # Get the tracking branch
  local tracking_branch
  tracking_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")

  if [[ -z "${tracking_branch}" ]]; then
    log_msg "WARN" "${app_name}: No tracking branch configured"
    return 1
  fi

  remote_head=$(git rev-parse "${tracking_branch}")

  # Check if update is needed
  if [[ "${local_head}" != "${remote_head}" ]]; then
    log_msg "INFO" "${app_name}: Update detected (${local_head:0:8} â†’ ${remote_head:0:8})"

    # Trigger update via appmo CLI
    if "${APPMO_CLI}" update "${app_name}"; then
      log_msg "INFO" "${app_name}: Successfully updated"
      return 0
    else
      log_msg "ERROR" "${app_name}: Update failed"
      return 1
    fi
  else
    log_msg "DEBUG" "${app_name}: No updates available"
    return 0
  fi
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
main() {
  # Acquire lock to prevent concurrent runs
  acquire_lock
  trap release_lock EXIT

  log_msg "INFO" "Starting autopull check"

  # Check if apps directory exists
  if [[ ! -d "${APPS_CONFIG_DIR}" ]]; then
    log_msg "INFO" "No apps configured yet"
    exit 0
  fi

  # Get list of all apps
  local app_count=0
  local updated_count=0

  for app_dir in "${APPS_CONFIG_DIR}"/*; do
    if [[ ! -d "${app_dir}" ]]; then
      continue
    fi

    local app_name
    app_name=$(basename "${app_dir}")
    app_count=$((app_count + 1))

    if check_app_for_updates "${app_name}"; then
      # Check if the app was actually updated (not just "no updates")
      if [[ "${local_head:-}" != "${remote_head:-}" ]]; then
        updated_count=$((updated_count + 1))
      fi
    fi
  done

  if [[ ${app_count} -eq 0 ]]; then
    log_msg "INFO" "No apps found"
  elif [[ ${updated_count} -eq 0 ]]; then
    log_msg "INFO" "Checked ${app_count} app(s), no updates available"
  else
    log_msg "INFO" "Checked ${app_count} app(s), updated ${updated_count}"
  fi
}

main "$@"
